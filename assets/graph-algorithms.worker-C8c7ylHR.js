(function(){"use strict";function Se(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}var ke={exports:{}},Et;function br(){if(Et)return ke.exports;Et=1;var o=typeof Reflect=="object"?Reflect:null,e=o&&typeof o.apply=="function"?o.apply:function(y,v,_){return Function.prototype.apply.call(y,v,_)},t;o&&typeof o.ownKeys=="function"?t=o.ownKeys:Object.getOwnPropertySymbols?t=function(y){return Object.getOwnPropertyNames(y).concat(Object.getOwnPropertySymbols(y))}:t=function(y){return Object.getOwnPropertyNames(y)};function r(w){console&&console.warn&&console.warn(w)}var i=Number.isNaN||function(y){return y!==y};function n(){n.init.call(this)}ke.exports=n,ke.exports.once=I,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._eventsCount=0,n.prototype._maxListeners=void 0;var s=10;function u(w){if(typeof w!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof w)}Object.defineProperty(n,"defaultMaxListeners",{enumerable:!0,get:function(){return s},set:function(w){if(typeof w!="number"||w<0||i(w))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+w+".");s=w}}),n.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},n.prototype.setMaxListeners=function(y){if(typeof y!="number"||y<0||i(y))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+y+".");return this._maxListeners=y,this};function d(w){return w._maxListeners===void 0?n.defaultMaxListeners:w._maxListeners}n.prototype.getMaxListeners=function(){return d(this)},n.prototype.emit=function(y){for(var v=[],_=1;_<arguments.length;_++)v.push(arguments[_]);var L=y==="error",R=this._events;if(R!==void 0)L=L&&R.error===void 0;else if(!L)return!1;if(L){var O;if(v.length>0&&(O=v[0]),O instanceof Error)throw O;var J=new Error("Unhandled error."+(O?" ("+O.message+")":""));throw J.context=O,J}var j=R[y];if(j===void 0)return!1;if(typeof j=="function")e(j,this,v);else for(var h=j.length,we=$(j,h),_=0;_<h;++_)e(we[_],this,v);return!0};function a(w,y,v,_){var L,R,O;if(u(v),R=w._events,R===void 0?(R=w._events=Object.create(null),w._eventsCount=0):(R.newListener!==void 0&&(w.emit("newListener",y,v.listener?v.listener:v),R=w._events),O=R[y]),O===void 0)O=R[y]=v,++w._eventsCount;else if(typeof O=="function"?O=R[y]=_?[v,O]:[O,v]:_?O.unshift(v):O.push(v),L=d(w),L>0&&O.length>L&&!O.warned){O.warned=!0;var J=new Error("Possible EventEmitter memory leak detected. "+O.length+" "+String(y)+" listeners added. Use emitter.setMaxListeners() to increase limit");J.name="MaxListenersExceededWarning",J.emitter=w,J.type=y,J.count=O.length,r(J)}return w}n.prototype.addListener=function(y,v){return a(this,y,v,!1)},n.prototype.on=n.prototype.addListener,n.prototype.prependListener=function(y,v){return a(this,y,v,!0)};function c(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function f(w,y,v){var _={fired:!1,wrapFn:void 0,target:w,type:y,listener:v},L=c.bind(_);return L.listener=v,_.wrapFn=L,L}n.prototype.once=function(y,v){return u(v),this.on(y,f(this,y,v)),this},n.prototype.prependOnceListener=function(y,v){return u(v),this.prependListener(y,f(this,y,v)),this},n.prototype.removeListener=function(y,v){var _,L,R,O,J;if(u(v),L=this._events,L===void 0)return this;if(_=L[y],_===void 0)return this;if(_===v||_.listener===v)--this._eventsCount===0?this._events=Object.create(null):(delete L[y],L.removeListener&&this.emit("removeListener",y,_.listener||v));else if(typeof _!="function"){for(R=-1,O=_.length-1;O>=0;O--)if(_[O]===v||_[O].listener===v){J=_[O].listener,R=O;break}if(R<0)return this;R===0?_.shift():U(_,R),_.length===1&&(L[y]=_[0]),L.removeListener!==void 0&&this.emit("removeListener",y,J||v)}return this},n.prototype.off=n.prototype.removeListener,n.prototype.removeAllListeners=function(y){var v,_,L;if(_=this._events,_===void 0)return this;if(_.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):_[y]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete _[y]),this;if(arguments.length===0){var R=Object.keys(_),O;for(L=0;L<R.length;++L)O=R[L],O!=="removeListener"&&this.removeAllListeners(O);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(v=_[y],typeof v=="function")this.removeListener(y,v);else if(v!==void 0)for(L=v.length-1;L>=0;L--)this.removeListener(y,v[L]);return this};function g(w,y,v){var _=w._events;if(_===void 0)return[];var L=_[y];return L===void 0?[]:typeof L=="function"?v?[L.listener||L]:[L]:v?C(L):$(L,L.length)}n.prototype.listeners=function(y){return g(this,y,!0)},n.prototype.rawListeners=function(y){return g(this,y,!1)},n.listenerCount=function(w,y){return typeof w.listenerCount=="function"?w.listenerCount(y):b.call(w,y)},n.prototype.listenerCount=b;function b(w){var y=this._events;if(y!==void 0){var v=y[w];if(typeof v=="function")return 1;if(v!==void 0)return v.length}return 0}n.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]};function $(w,y){for(var v=new Array(y),_=0;_<y;++_)v[_]=w[_];return v}function U(w,y){for(;y+1<w.length;y++)w[y]=w[y+1];w.pop()}function C(w){for(var y=new Array(w.length),v=0;v<y.length;++v)y[v]=w[v].listener||w[v];return y}function I(w,y){return new Promise(function(v,_){function L(O){w.removeListener(y,R),_(O)}function R(){typeof w.removeListener=="function"&&w.removeListener("error",L),v([].slice.call(arguments))}z(w,y,R,{once:!0}),y!=="error"&&N(w,L,{once:!0})})}function N(w,y,v){typeof w.on=="function"&&z(w,"error",y,v)}function z(w,y,v,_){if(typeof w.on=="function")_.once?w.once(y,v):w.on(y,v);else if(typeof w.addEventListener=="function")w.addEventListener(y,function L(R){_.once&&w.removeEventListener(y,L),v(R)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof w)}return ke.exports}var mr=br(),qe,vt;function Pe(){if(vt)return qe;vt=1;function o(e){if(typeof e!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=e}return typeof Symbol<"u"&&(o.prototype[Symbol.iterator]=function(){return this}),o.of=function(){var e=arguments,t=e.length,r=0;return new o(function(){return r>=t?{done:!0}:{done:!1,value:e[r++]}})},o.empty=function(){var e=new o(function(){return{done:!0}});return e},o.fromSequence=function(e){var t=0,r=e.length;return new o(function(){return t>=r?{done:!0}:{done:!1,value:e[t++]}})},o.is=function(e){return e instanceof o?!0:typeof e=="object"&&e!==null&&typeof e.next=="function"},qe=o,qe}var Er=Pe(),Y=Se(Er),Le={},At;function vr(){return At||(At=1,Le.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u",Le.SYMBOL_SUPPORT=typeof Symbol<"u"),Le}var Ke,_t;function Gt(){if(_t)return Ke;_t=1;var o=Pe(),e=vr(),t=e.ARRAY_BUFFER_SUPPORT,r=e.SYMBOL_SUPPORT;function i(n){return typeof n=="string"||Array.isArray(n)||t&&ArrayBuffer.isView(n)?o.fromSequence(n):typeof n!="object"||n===null?null:r&&typeof n[Symbol.iterator]=="function"?n[Symbol.iterator]():typeof n.next=="function"?n:null}return Ke=function(s){var u=i(s);if(!u)throw new Error("obliterator: target is not iterable nor a valid iterator.");return u},Ke}var Be,$t;function Ar(){if($t)return Be;$t=1;var o=Gt();return Be=function(t,r){for(var i=arguments.length>1?r:1/0,n=i!==1/0?new Array(i):[],s,u=0,d=o(t);;){if(u===i)return n;if(s=d.next(),s.done)return u!==r&&(n.length=u),n;n[u++]=s.value}},Be}var _r=Ar(),Dt=Se(_r),xe,St;function Gr(){if(St)return xe;St=1;var o=Pe(),e=Gt();return xe=function(){var r=arguments,i=null,n=-1;return new o(function(){var u=null;do{if(i===null){if(n++,n>=r.length)return{done:!0};i=e(r[n])}if(u=i.next(),u.done===!0){i=null;continue}break}while(!0);return u})},xe}var $r=Gr(),re=Se($r);function Dr(){const o=arguments[0];for(let e=1,t=arguments.length;e<t;e++)if(arguments[e])for(const r in arguments[e])o[r]=arguments[e][r];return o}let B=Dr;typeof Object.assign=="function"&&(B=Object.assign);function V(o,e,t,r){const i=o._nodes.get(e);let n=null;return i&&(r==="mixed"?n=i.out&&i.out[t]||i.undirected&&i.undirected[t]:r==="directed"?n=i.out&&i.out[t]:n=i.undirected&&i.undirected[t]),n}function x(o){return typeof o=="object"&&o!==null}function kt(o){let e;for(e in o)return!1;return!0}function Z(o,e,t){Object.defineProperty(o,e,{enumerable:!1,configurable:!1,writable:!0,value:t})}function X(o,e,t){const r={enumerable:!0,configurable:!0};typeof t=="function"?r.get=t:(r.value=t,r.writable=!1),Object.defineProperty(o,e,r)}function Lt(o){return!(!x(o)||o.attributes&&!Array.isArray(o.attributes))}function Sr(){let o=Math.floor(Math.random()*256)&255;return()=>o++}class He extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}let A=class wr extends He{constructor(e){super(e),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,wr.prototype.constructor)}};class m extends He{constructor(e){super(e),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,m.prototype.constructor)}}class G extends He{constructor(e){super(e),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G.prototype.constructor)}}function Ut(o,e){this.key=o,this.attributes=e,this.clear()}Ut.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}};function Rt(o,e){this.key=o,this.attributes=e,this.clear()}Rt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}};function Ot(o,e){this.key=o,this.attributes=e,this.clear()}Ot.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}};function he(o,e,t,r,i){this.key=e,this.attributes=i,this.undirected=o,this.source=t,this.target=r}he.prototype.attach=function(){let o="out",e="in";this.undirected&&(o=e="undirected");const t=this.source.key,r=this.target.key;this.source[o][r]=this,!(this.undirected&&t===r)&&(this.target[e][t]=this)},he.prototype.attachMulti=function(){let o="out",e="in";const t=this.source.key,r=this.target.key;this.undirected&&(o=e="undirected");const i=this.source[o],n=i[r];if(typeof n>"u"){i[r]=this,this.undirected&&t===r||(this.target[e][t]=this);return}n.previous=this,this.next=n,i[r]=this,this.target[e][t]=this},he.prototype.detach=function(){const o=this.source.key,e=this.target.key;let t="out",r="in";this.undirected&&(t=r="undirected"),delete this.source[t][e],delete this.target[r][o]},he.prototype.detachMulti=function(){const o=this.source.key,e=this.target.key;let t="out",r="in";this.undirected&&(t=r="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[t][e],delete this.target[r][o]):(this.next.previous=void 0,this.source[t][e]=this.next,this.target[r][o]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const Nt=0,Ct=1,kr=2,It=3;function ie(o,e,t,r,i,n,s){let u,d,a,c;if(r=""+r,t===Nt){if(u=o._nodes.get(r),!u)throw new m(`Graph.${e}: could not find the "${r}" node in the graph.`);a=i,c=n}else if(t===It){if(i=""+i,d=o._edges.get(i),!d)throw new m(`Graph.${e}: could not find the "${i}" edge in the graph.`);const f=d.source.key,g=d.target.key;if(r===f)u=d.target;else if(r===g)u=d.source;else throw new m(`Graph.${e}: the "${r}" node is not attached to the "${i}" edge (${f}, ${g}).`);a=n,c=s}else{if(d=o._edges.get(r),!d)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`);t===Ct?u=d.source:u=d.target,a=i,c=n}return[u,a,c]}function Lr(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=ie(this,e,t,r,i,n);return s.attributes[u]}}function Ur(o,e,t){o.prototype[e]=function(r,i){const[n]=ie(this,e,t,r,i);return n.attributes}}function Rr(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=ie(this,e,t,r,i,n);return s.attributes.hasOwnProperty(u)}}function Or(o,e,t){o.prototype[e]=function(r,i,n,s){const[u,d,a]=ie(this,e,t,r,i,n,s);return u.attributes[d]=a,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:d}),this}}function Nr(o,e,t){o.prototype[e]=function(r,i,n,s){const[u,d,a]=ie(this,e,t,r,i,n,s);if(typeof a!="function")throw new A(`Graph.${e}: updater should be a function.`);const c=u.attributes,f=a(c[d]);return c[d]=f,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:d}),this}}function Cr(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=ie(this,e,t,r,i,n);return delete s.attributes[u],this.emit("nodeAttributesUpdated",{key:s.key,type:"remove",attributes:s.attributes,name:u}),this}}function Ir(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=ie(this,e,t,r,i,n);if(!x(u))throw new A(`Graph.${e}: provided attributes are not a plain object.`);return s.attributes=u,this.emit("nodeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}function jr(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=ie(this,e,t,r,i,n);if(!x(u))throw new A(`Graph.${e}: provided attributes are not a plain object.`);return B(s.attributes,u),this.emit("nodeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:u}),this}}function Fr(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=ie(this,e,t,r,i,n);if(typeof u!="function")throw new A(`Graph.${e}: provided updater is not a function.`);return s.attributes=u(s.attributes),this.emit("nodeAttributesUpdated",{key:s.key,type:"update",attributes:s.attributes}),this}}const Tr=[{name:o=>`get${o}Attribute`,attacher:Lr},{name:o=>`get${o}Attributes`,attacher:Ur},{name:o=>`has${o}Attribute`,attacher:Rr},{name:o=>`set${o}Attribute`,attacher:Or},{name:o=>`update${o}Attribute`,attacher:Nr},{name:o=>`remove${o}Attribute`,attacher:Cr},{name:o=>`replace${o}Attributes`,attacher:Ir},{name:o=>`merge${o}Attributes`,attacher:jr},{name:o=>`update${o}Attributes`,attacher:Fr}];function Wr(o){Tr.forEach(function({name:e,attacher:t}){t(o,e("Node"),Nt),t(o,e("Source"),Ct),t(o,e("Target"),kr),t(o,e("Opposite"),It)})}function zr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new m(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return n.attributes[i]}}function qr(o,e,t){o.prototype[e]=function(r){let i;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const n=""+r,s=""+arguments[1];if(i=V(this,n,s,t),!i)throw new m(`Graph.${e}: could not find an edge for the given path ("${n}" - "${s}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,i=this._edges.get(r),!i)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return i.attributes}}function Pr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new m(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return n.attributes.hasOwnProperty(i)}}function Kr(o,e,t){o.prototype[e]=function(r,i,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const u=""+r,d=""+i;if(i=arguments[2],n=arguments[3],s=V(this,u,d,t),!s)throw new m(`Graph.${e}: could not find an edge for the given path ("${u}" - "${d}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return s.attributes[i]=n,this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:i}),this}}function Br(o,e,t){o.prototype[e]=function(r,i,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const u=""+r,d=""+i;if(i=arguments[2],n=arguments[3],s=V(this,u,d,t),!s)throw new m(`Graph.${e}: could not find an edge for the given path ("${u}" - "${d}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(typeof n!="function")throw new A(`Graph.${e}: updater should be a function.`);return s.attributes[i]=n(s.attributes[i]),this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:i}),this}}function xr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new m(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return delete n.attributes[i],this.emit("edgeAttributesUpdated",{key:n.key,type:"remove",attributes:n.attributes,name:i}),this}}function Hr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new m(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(!x(i))throw new A(`Graph.${e}: provided attributes are not a plain object.`);return n.attributes=i,this.emit("edgeAttributesUpdated",{key:n.key,type:"replace",attributes:n.attributes}),this}}function Yr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new m(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(!x(i))throw new A(`Graph.${e}: provided attributes are not a plain object.`);return B(n.attributes,i),this.emit("edgeAttributesUpdated",{key:n.key,type:"merge",attributes:n.attributes,data:i}),this}}function Vr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new m(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new m(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(typeof i!="function")throw new A(`Graph.${e}: provided updater is not a function.`);return n.attributes=i(n.attributes),this.emit("edgeAttributesUpdated",{key:n.key,type:"update",attributes:n.attributes}),this}}const Zr=[{name:o=>`get${o}Attribute`,attacher:zr},{name:o=>`get${o}Attributes`,attacher:qr},{name:o=>`has${o}Attribute`,attacher:Pr},{name:o=>`set${o}Attribute`,attacher:Kr},{name:o=>`update${o}Attribute`,attacher:Br},{name:o=>`remove${o}Attribute`,attacher:xr},{name:o=>`replace${o}Attributes`,attacher:Hr},{name:o=>`merge${o}Attributes`,attacher:Yr},{name:o=>`update${o}Attributes`,attacher:Vr}];function Jr(o){Zr.forEach(function({name:e,attacher:t}){t(o,e("Edge"),"mixed"),t(o,e("DirectedEdge"),"directed"),t(o,e("UndirectedEdge"),"undirected")})}const Qr=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function Xr(o,e,t,r){let i=!1;for(const n in e){if(n===r)continue;const s=e[n];if(i=t(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),o&&i)return s.key}}function Mr(o,e,t,r){let i,n,s,u=!1;for(const d in e)if(d!==r){i=e[d];do{if(n=i.source,s=i.target,u=t(i.key,i.attributes,n.key,s.key,n.attributes,s.attributes,i.undirected),o&&u)return i.key;i=i.next}while(i!==void 0)}}function Ye(o,e){const t=Object.keys(o),r=t.length;let i,n=0;return new Y(function(){do if(i)i=i.next;else{if(n>=r)return{done:!0};const u=t[n++];if(u===e){i=void 0;continue}i=o[u]}while(!i);return{done:!1,value:{edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected}}})}function ei(o,e,t,r){const i=e[t];if(!i)return;const n=i.source,s=i.target;if(r(i.key,i.attributes,n.key,s.key,n.attributes,s.attributes,i.undirected)&&o)return i.key}function ti(o,e,t,r){let i=e[t];if(!i)return;let n=!1;do{if(n=r(i.key,i.attributes,i.source.key,i.target.key,i.source.attributes,i.target.attributes,i.undirected),o&&n)return i.key;i=i.next}while(i!==void 0)}function Ve(o,e){let t=o[e];return t.next!==void 0?new Y(function(){if(!t)return{done:!0};const r={edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected};return t=t.next,{done:!1,value:r}}):Y.of({edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected})}function ri(o,e){if(o.size===0)return[];if(e==="mixed"||e===o.type)return typeof Array.from=="function"?Array.from(o._edges.keys()):Dt(o._edges.keys(),o._edges.size);const t=e==="undirected"?o.undirectedSize:o.directedSize,r=new Array(t),i=e==="undirected",n=o._edges.values();let s=0,u,d;for(;u=n.next(),u.done!==!0;)d=u.value,d.undirected===i&&(r[s++]=d.key);return r}function jt(o,e,t,r){if(e.size===0)return;const i=t!=="mixed"&&t!==e.type,n=t==="undirected";let s,u,d=!1;const a=e._edges.values();for(;s=a.next(),s.done!==!0;){if(u=s.value,i&&u.undirected!==n)continue;const{key:c,attributes:f,source:g,target:b}=u;if(d=r(c,f,g.key,b.key,g.attributes,b.attributes,u.undirected),o&&d)return c}}function ii(o,e){if(o.size===0)return Y.empty();const t=e!=="mixed"&&e!==o.type,r=e==="undirected",i=o._edges.values();return new Y(function(){let s,u;for(;;){if(s=i.next(),s.done)return s;if(u=s.value,!(t&&u.undirected!==r))break}return{value:{edge:u.key,attributes:u.attributes,source:u.source.key,target:u.target.key,sourceAttributes:u.source.attributes,targetAttributes:u.target.attributes,undirected:u.undirected},done:!1}})}function Ze(o,e,t,r,i,n){const s=e?Mr:Xr;let u;if(t!=="undirected"&&(r!=="out"&&(u=s(o,i.in,n),o&&u)||r!=="in"&&(u=s(o,i.out,n,r?void 0:i.key),o&&u))||t!=="directed"&&(u=s(o,i.undirected,n),o&&u))return u}function ni(o,e,t,r){const i=[];return Ze(!1,o,e,t,r,function(n){i.push(n)}),i}function oi(o,e,t){let r=Y.empty();return o!=="undirected"&&(e!=="out"&&typeof t.in<"u"&&(r=re(r,Ye(t.in))),e!=="in"&&typeof t.out<"u"&&(r=re(r,Ye(t.out,e?void 0:t.key)))),o!=="directed"&&typeof t.undirected<"u"&&(r=re(r,Ye(t.undirected))),r}function Je(o,e,t,r,i,n,s){const u=t?ti:ei;let d;if(e!=="undirected"&&(typeof i.in<"u"&&r!=="out"&&(d=u(o,i.in,n,s),o&&d)||typeof i.out<"u"&&r!=="in"&&(r||i.key!==n)&&(d=u(o,i.out,n,s),o&&d))||e!=="directed"&&typeof i.undirected<"u"&&(d=u(o,i.undirected,n,s),o&&d))return d}function si(o,e,t,r,i){const n=[];return Je(!1,o,e,t,r,i,function(s){n.push(s)}),n}function ui(o,e,t,r){let i=Y.empty();return o!=="undirected"&&(typeof t.in<"u"&&e!=="out"&&r in t.in&&(i=re(i,Ve(t.in,r))),typeof t.out<"u"&&e!=="in"&&r in t.out&&(e||t.key!==r)&&(i=re(i,Ve(t.out,r)))),o!=="directed"&&typeof t.undirected<"u"&&r in t.undirected&&(i=re(i,Ve(t.undirected,r))),i}function ai(o,e){const{name:t,type:r,direction:i}=e;o.prototype[t]=function(n,s){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return[];if(!arguments.length)return ri(this,r);if(arguments.length===1){n=""+n;const u=this._nodes.get(n);if(typeof u>"u")throw new m(`Graph.${t}: could not find the "${n}" node in the graph.`);return ni(this.multi,r==="mixed"?this.type:r,i,u)}if(arguments.length===2){n=""+n,s=""+s;const u=this._nodes.get(n);if(!u)throw new m(`Graph.${t}:  could not find the "${n}" source node in the graph.`);if(!this._nodes.has(s))throw new m(`Graph.${t}:  could not find the "${s}" target node in the graph.`);return si(r,this.multi,i,u,s)}throw new A(`Graph.${t}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function di(o,e){const{name:t,type:r,direction:i}=e,n="forEach"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[n]=function(a,c,f){if(!(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)){if(arguments.length===1)return f=a,jt(!1,this,r,f);if(arguments.length===2){a=""+a,f=c;const g=this._nodes.get(a);if(typeof g>"u")throw new m(`Graph.${n}: could not find the "${a}" node in the graph.`);return Ze(!1,this.multi,r==="mixed"?this.type:r,i,g,f)}if(arguments.length===3){a=""+a,c=""+c;const g=this._nodes.get(a);if(!g)throw new m(`Graph.${n}:  could not find the "${a}" source node in the graph.`);if(!this._nodes.has(c))throw new m(`Graph.${n}:  could not find the "${c}" target node in the graph.`);return Je(!1,r,this.multi,i,g,c,f)}throw new A(`Graph.${n}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const s="map"+t[0].toUpperCase()+t.slice(1);o.prototype[s]=function(){const a=Array.prototype.slice.call(arguments),c=a.pop();let f;if(a.length===0){let g=0;r!=="directed"&&(g+=this.undirectedSize),r!=="undirected"&&(g+=this.directedSize),f=new Array(g);let b=0;a.push(($,U,C,I,N,z,w)=>{f[b++]=c($,U,C,I,N,z,w)})}else f=[],a.push((g,b,$,U,C,I,N)=>{f.push(c(g,b,$,U,C,I,N))});return this[n].apply(this,a),f};const u="filter"+t[0].toUpperCase()+t.slice(1);o.prototype[u]=function(){const a=Array.prototype.slice.call(arguments),c=a.pop(),f=[];return a.push((g,b,$,U,C,I,N)=>{c(g,b,$,U,C,I,N)&&f.push(g)}),this[n].apply(this,a),f};const d="reduce"+t[0].toUpperCase()+t.slice(1);o.prototype[d]=function(){let a=Array.prototype.slice.call(arguments);if(a.length<2||a.length>4)throw new A(`Graph.${d}: invalid number of arguments (expecting 2, 3 or 4 and got ${a.length}).`);if(typeof a[a.length-1]=="function"&&typeof a[a.length-2]!="function")throw new A(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let c,f;a.length===2?(c=a[0],f=a[1],a=[]):a.length===3?(c=a[1],f=a[2],a=[a[0]]):a.length===4&&(c=a[2],f=a[3],a=[a[0],a[1]]);let g=f;return a.push((b,$,U,C,I,N,z)=>{g=c(g,b,$,U,C,I,N,z)}),this[n].apply(this,a),g}}function ci(o,e){const{name:t,type:r,direction:i}=e,n="find"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[n]=function(d,a,c){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return!1;if(arguments.length===1)return c=d,jt(!0,this,r,c);if(arguments.length===2){d=""+d,c=a;const f=this._nodes.get(d);if(typeof f>"u")throw new m(`Graph.${n}: could not find the "${d}" node in the graph.`);return Ze(!0,this.multi,r==="mixed"?this.type:r,i,f,c)}if(arguments.length===3){d=""+d,a=""+a;const f=this._nodes.get(d);if(!f)throw new m(`Graph.${n}:  could not find the "${d}" source node in the graph.`);if(!this._nodes.has(a))throw new m(`Graph.${n}:  could not find the "${a}" target node in the graph.`);return Je(!0,r,this.multi,i,f,a,c)}throw new A(`Graph.${n}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const s="some"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[s]=function(){const d=Array.prototype.slice.call(arguments),a=d.pop();return d.push((f,g,b,$,U,C,I)=>a(f,g,b,$,U,C,I)),!!this[n].apply(this,d)};const u="every"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[u]=function(){const d=Array.prototype.slice.call(arguments),a=d.pop();return d.push((f,g,b,$,U,C,I)=>!a(f,g,b,$,U,C,I)),!this[n].apply(this,d)}}function hi(o,e){const{name:t,type:r,direction:i}=e,n=t.slice(0,-1)+"Entries";o.prototype[n]=function(s,u){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return Y.empty();if(!arguments.length)return ii(this,r);if(arguments.length===1){s=""+s;const d=this._nodes.get(s);if(!d)throw new m(`Graph.${n}: could not find the "${s}" node in the graph.`);return oi(r,i,d)}if(arguments.length===2){s=""+s,u=""+u;const d=this._nodes.get(s);if(!d)throw new m(`Graph.${n}:  could not find the "${s}" source node in the graph.`);if(!this._nodes.has(u))throw new m(`Graph.${n}:  could not find the "${u}" target node in the graph.`);return ui(r,i,d,u)}throw new A(`Graph.${n}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function fi(o){Qr.forEach(e=>{ai(o,e),di(o,e),ci(o,e),hi(o,e)})}const li=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function Ue(){this.A=null,this.B=null}Ue.prototype.wrap=function(o){this.A===null?this.A=o:this.B===null&&(this.B=o)},Ue.prototype.has=function(o){return this.A!==null&&o in this.A||this.B!==null&&o in this.B};function Ae(o,e,t,r,i){for(const n in r){const s=r[n],u=s.source,d=s.target,a=u===t?d:u;if(e&&e.has(a.key))continue;const c=i(a.key,a.attributes);if(o&&c)return a.key}}function Qe(o,e,t,r,i){if(e!=="mixed"){if(e==="undirected")return Ae(o,null,r,r.undirected,i);if(typeof t=="string")return Ae(o,null,r,r[t],i)}const n=new Ue;let s;if(e!=="undirected"){if(t!=="out"){if(s=Ae(o,null,r,r.in,i),o&&s)return s;n.wrap(r.in)}if(t!=="in"){if(s=Ae(o,n,r,r.out,i),o&&s)return s;n.wrap(r.out)}}if(e!=="directed"&&(s=Ae(o,n,r,r.undirected,i),o&&s))return s}function pi(o,e,t){if(o!=="mixed"){if(o==="undirected")return Object.keys(t.undirected);if(typeof e=="string")return Object.keys(t[e])}const r=[];return Qe(!1,o,e,t,function(i){r.push(i)}),r}function _e(o,e,t){const r=Object.keys(t),i=r.length;let n=0;return new Y(function(){let u=null;do{if(n>=i)return o&&o.wrap(t),{done:!0};const d=t[r[n++]],a=d.source,c=d.target;if(u=a===e?c:a,o&&o.has(u.key)){u=null;continue}}while(u===null);return{done:!1,value:{neighbor:u.key,attributes:u.attributes}}})}function gi(o,e,t){if(o!=="mixed"){if(o==="undirected")return _e(null,t,t.undirected);if(typeof e=="string")return _e(null,t,t[e])}let r=Y.empty();const i=new Ue;return o!=="undirected"&&(e!=="out"&&(r=re(r,_e(i,t,t.in))),e!=="in"&&(r=re(r,_e(i,t,t.out)))),o!=="directed"&&(r=re(r,_e(i,t,t.undirected))),r}function yi(o,e){const{name:t,type:r,direction:i}=e;o.prototype[t]=function(n){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return[];n=""+n;const s=this._nodes.get(n);if(typeof s>"u")throw new m(`Graph.${t}: could not find the "${n}" node in the graph.`);return pi(r==="mixed"?this.type:r,i,s)}}function wi(o,e){const{name:t,type:r,direction:i}=e,n="forEach"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[n]=function(a,c){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return;a=""+a;const f=this._nodes.get(a);if(typeof f>"u")throw new m(`Graph.${n}: could not find the "${a}" node in the graph.`);Qe(!1,r==="mixed"?this.type:r,i,f,c)};const s="map"+t[0].toUpperCase()+t.slice(1);o.prototype[s]=function(a,c){const f=[];return this[n](a,(g,b)=>{f.push(c(g,b))}),f};const u="filter"+t[0].toUpperCase()+t.slice(1);o.prototype[u]=function(a,c){const f=[];return this[n](a,(g,b)=>{c(g,b)&&f.push(g)}),f};const d="reduce"+t[0].toUpperCase()+t.slice(1);o.prototype[d]=function(a,c,f){if(arguments.length<3)throw new A(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let g=f;return this[n](a,(b,$)=>{g=c(g,b,$)}),g}}function bi(o,e){const{name:t,type:r,direction:i}=e,n=t[0].toUpperCase()+t.slice(1,-1),s="find"+n;o.prototype[s]=function(a,c){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return;a=""+a;const f=this._nodes.get(a);if(typeof f>"u")throw new m(`Graph.${s}: could not find the "${a}" node in the graph.`);return Qe(!0,r==="mixed"?this.type:r,i,f,c)};const u="some"+n;o.prototype[u]=function(a,c){return!!this[s](a,c)};const d="every"+n;o.prototype[d]=function(a,c){return!this[s](a,(g,b)=>!c(g,b))}}function mi(o,e){const{name:t,type:r,direction:i}=e,n=t.slice(0,-1)+"Entries";o.prototype[n]=function(s){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return Y.empty();s=""+s;const u=this._nodes.get(s);if(typeof u>"u")throw new m(`Graph.${n}: could not find the "${s}" node in the graph.`);return gi(r==="mixed"?this.type:r,i,u)}}function Ei(o){li.forEach(e=>{yi(o,e),wi(o,e),bi(o,e),mi(o,e)})}function Re(o,e,t,r,i){const n=r._nodes.values(),s=r.type;let u,d,a,c,f,g;for(;u=n.next(),u.done!==!0;){let b=!1;if(d=u.value,s!=="undirected"){c=d.out;for(a in c){f=c[a];do g=f.target,b=!0,i(d.key,g.key,d.attributes,g.attributes,f.key,f.attributes,f.undirected),f=f.next;while(f)}}if(s!=="directed"){c=d.undirected;for(a in c)if(!(e&&d.key>a)){f=c[a];do g=f.target,g.key!==a&&(g=f.source),b=!0,i(d.key,g.key,d.attributes,g.attributes,f.key,f.attributes,f.undirected),f=f.next;while(f)}}t&&!b&&i(d.key,null,d.attributes,null,null,null,null)}}function vi(o,e){const t={key:o};return kt(e.attributes)||(t.attributes=B({},e.attributes)),t}function Ai(o,e,t){const r={key:e,source:t.source.key,target:t.target.key};return kt(t.attributes)||(r.attributes=B({},t.attributes)),o==="mixed"&&t.undirected&&(r.undirected=!0),r}function _i(o){if(!x(o))throw new A('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in o))throw new A("Graph.import: serialized node is missing its key.");if("attributes"in o&&(!x(o.attributes)||o.attributes===null))throw new A("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function Gi(o){if(!x(o))throw new A('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in o))throw new A("Graph.import: serialized edge is missing its source.");if(!("target"in o))throw new A("Graph.import: serialized edge is missing its target.");if("attributes"in o&&(!x(o.attributes)||o.attributes===null))throw new A("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in o&&typeof o.undirected!="boolean")throw new A("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const $i=Sr(),Di=new Set(["directed","undirected","mixed"]),Ft=new Set(["domain","_events","_eventsCount","_maxListeners"]),Si=[{name:o=>`${o}Edge`,generateKey:!0},{name:o=>`${o}DirectedEdge`,generateKey:!0,type:"directed"},{name:o=>`${o}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:o=>`${o}EdgeWithKey`},{name:o=>`${o}DirectedEdgeWithKey`,type:"directed"},{name:o=>`${o}UndirectedEdgeWithKey`,type:"undirected"}],ki={allowSelfLoops:!0,multi:!1,type:"mixed"};function Li(o,e,t){if(t&&!x(t))throw new A(`Graph.addNode: invalid attributes. Expecting an object but got "${t}"`);if(e=""+e,t=t||{},o._nodes.has(e))throw new G(`Graph.addNode: the "${e}" node already exist in the graph.`);const r=new o.NodeDataClass(e,t);return o._nodes.set(e,r),o.emit("nodeAdded",{key:e,attributes:t}),r}function Tt(o,e,t){const r=new o.NodeDataClass(e,t);return o._nodes.set(e,r),o.emit("nodeAdded",{key:e,attributes:t}),r}function Wt(o,e,t,r,i,n,s,u){if(!r&&o.type==="undirected")throw new G(`Graph.${e}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(r&&o.type==="directed")throw new G(`Graph.${e}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(u&&!x(u))throw new A(`Graph.${e}: invalid attributes. Expecting an object but got "${u}"`);if(n=""+n,s=""+s,u=u||{},!o.allowSelfLoops&&n===s)throw new G(`Graph.${e}: source & target are the same ("${n}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const d=o._nodes.get(n),a=o._nodes.get(s);if(!d)throw new m(`Graph.${e}: source node "${n}" not found.`);if(!a)throw new m(`Graph.${e}: target node "${s}" not found.`);const c={key:null,undirected:r,source:n,target:s,attributes:u};if(t)i=o._edgeKeyGenerator();else if(i=""+i,o._edges.has(i))throw new G(`Graph.${e}: the "${i}" edge already exists in the graph.`);if(!o.multi&&(r?typeof d.undirected[s]<"u":typeof d.out[s]<"u"))throw new G(`Graph.${e}: an edge linking "${n}" to "${s}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const f=new he(r,i,d,a,u);o._edges.set(i,f);const g=n===s;return r?(d.undirectedDegree++,a.undirectedDegree++,g&&(d.undirectedLoops++,o._undirectedSelfLoopCount++)):(d.outDegree++,a.inDegree++,g&&(d.directedLoops++,o._directedSelfLoopCount++)),o.multi?f.attachMulti():f.attach(),r?o._undirectedSize++:o._directedSize++,c.key=i,o.emit("edgeAdded",c),i}function Ui(o,e,t,r,i,n,s,u,d){if(!r&&o.type==="undirected")throw new G(`Graph.${e}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(r&&o.type==="directed")throw new G(`Graph.${e}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(u){if(d){if(typeof u!="function")throw new A(`Graph.${e}: invalid updater function. Expecting a function but got "${u}"`)}else if(!x(u))throw new A(`Graph.${e}: invalid attributes. Expecting an object but got "${u}"`)}n=""+n,s=""+s;let a;if(d&&(a=u,u=void 0),!o.allowSelfLoops&&n===s)throw new G(`Graph.${e}: source & target are the same ("${n}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let c=o._nodes.get(n),f=o._nodes.get(s),g,b;if(!t&&(g=o._edges.get(i),g)){if((g.source.key!==n||g.target.key!==s)&&(!r||g.source.key!==s||g.target.key!==n))throw new G(`Graph.${e}: inconsistency detected when attempting to merge the "${i}" edge with "${n}" source & "${s}" target vs. ("${g.source.key}", "${g.target.key}").`);b=g}if(!b&&!o.multi&&c&&(b=r?c.undirected[s]:c.out[s]),b){const N=[b.key,!1,!1,!1];if(d?!a:!u)return N;if(d){const z=b.attributes;b.attributes=a(z),o.emit("edgeAttributesUpdated",{type:"replace",key:b.key,attributes:b.attributes})}else B(b.attributes,u),o.emit("edgeAttributesUpdated",{type:"merge",key:b.key,attributes:b.attributes,data:u});return N}u=u||{},d&&a&&(u=a(u));const $={key:null,undirected:r,source:n,target:s,attributes:u};if(t)i=o._edgeKeyGenerator();else if(i=""+i,o._edges.has(i))throw new G(`Graph.${e}: the "${i}" edge already exists in the graph.`);let U=!1,C=!1;c||(c=Tt(o,n,{}),U=!0,n===s&&(f=c,C=!0)),f||(f=Tt(o,s,{}),C=!0),g=new he(r,i,c,f,u),o._edges.set(i,g);const I=n===s;return r?(c.undirectedDegree++,f.undirectedDegree++,I&&(c.undirectedLoops++,o._undirectedSelfLoopCount++)):(c.outDegree++,f.inDegree++,I&&(c.directedLoops++,o._directedSelfLoopCount++)),o.multi?g.attachMulti():g.attach(),r?o._undirectedSize++:o._directedSize++,$.key=i,o.emit("edgeAdded",$),[i,!0,U,C]}function fe(o,e){o._edges.delete(e.key);const{source:t,target:r,attributes:i}=e,n=e.undirected,s=t===r;n?(t.undirectedDegree--,r.undirectedDegree--,s&&(t.undirectedLoops--,o._undirectedSelfLoopCount--)):(t.outDegree--,r.inDegree--,s&&(t.directedLoops--,o._directedSelfLoopCount--)),o.multi?e.detachMulti():e.detach(),n?o._undirectedSize--:o._directedSize--,o.emit("edgeDropped",{key:e.key,attributes:i,source:t.key,target:r.key,undirected:n})}class W extends mr.EventEmitter{constructor(e){if(super(),e=B({},ki,e),typeof e.multi!="boolean")throw new A(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!Di.has(e.type))throw new A(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if(typeof e.allowSelfLoops!="boolean")throw new A(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);const t=e.type==="mixed"?Ut:e.type==="directed"?Rt:Ot;Z(this,"NodeDataClass",t);const r="geid_"+$i()+"_";let i=0;const n=()=>{let s;do s=r+i++;while(this._edges.has(s));return s};Z(this,"_attributes",{}),Z(this,"_nodes",new Map),Z(this,"_edges",new Map),Z(this,"_directedSize",0),Z(this,"_undirectedSize",0),Z(this,"_directedSelfLoopCount",0),Z(this,"_undirectedSelfLoopCount",0),Z(this,"_edgeKeyGenerator",n),Z(this,"_options",e),Ft.forEach(s=>Z(this,s,this[s])),X(this,"order",()=>this._nodes.size),X(this,"size",()=>this._edges.size),X(this,"directedSize",()=>this._directedSize),X(this,"undirectedSize",()=>this._undirectedSize),X(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),X(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),X(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),X(this,"multi",this._options.multi),X(this,"type",this._options.type),X(this,"allowSelfLoops",this._options.allowSelfLoops),X(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if(this.type==="undirected")return!1;if(arguments.length===1){const r=""+e,i=this._edges.get(r);return!!i&&!i.undirected}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);return r?r.out.hasOwnProperty(t):!1}throw new A(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if(this.type==="directed")return!1;if(arguments.length===1){const r=""+e,i=this._edges.get(r);return!!i&&i.undirected}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);return r?r.undirected.hasOwnProperty(t):!1}throw new A(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(arguments.length===1){const r=""+e;return this._edges.has(r)}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);return r?typeof r.out<"u"&&r.out.hasOwnProperty(t)||typeof r.undirected<"u"&&r.undirected.hasOwnProperty(t):!1}throw new A(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if(this.type==="undirected")return;if(e=""+e,t=""+t,this.multi)throw new G("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const r=this._nodes.get(e);if(!r)throw new m(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new m(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);const i=r.out&&r.out[t]||void 0;if(i)return i.key}undirectedEdge(e,t){if(this.type==="directed")return;if(e=""+e,t=""+t,this.multi)throw new G("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const r=this._nodes.get(e);if(!r)throw new m(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new m(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);const i=r.undirected&&r.undirected[t]||void 0;if(i)return i.key}edge(e,t){if(this.multi)throw new G("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new m(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new m(`Graph.edge: could not find the "${t}" target node in the graph.`);const i=r.out&&r.out[t]||r.undirected&&r.undirected[t]||void 0;if(i)return i.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new m(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.in||t in r.out}areOutNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new m(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.out}areInNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new m(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new m(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="directed"?!1:t in r.undirected}areNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new m(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&(t in r.in||t in r.out)||this.type!=="directed"&&t in r.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new m(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in r.in||this.type!=="directed"&&t in r.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new m(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in r.out||this.type!=="directed"&&t in r.undirected}inDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.inDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree}outDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.outDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree}directedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree}inboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.inDegree),r}outboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.outDegree),r}degree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.degree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.inDegree+t.outDegree),r}inDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree-t.directedLoops*2}undirectedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree-t.undirectedLoops*2}inboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return this.type!=="directed"&&(r+=t.undirectedDegree,i+=t.undirectedLoops*2),this.type!=="undirected"&&(r+=t.inDegree,i+=t.directedLoops),r-i}outboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return this.type!=="directed"&&(r+=t.undirectedDegree,i+=t.undirectedLoops*2),this.type!=="undirected"&&(r+=t.outDegree,i+=t.directedLoops),r-i}degreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return this.type!=="directed"&&(r+=t.undirectedDegree,i+=t.undirectedLoops*2),this.type!=="undirected"&&(r+=t.inDegree+t.outDegree,i+=t.directedLoops*2),r-i}source(e){e=""+e;const t=this._edges.get(e);if(!t)throw new m(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;const t=this._edges.get(e);if(!t)throw new m(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;const t=this._edges.get(e);if(!t)throw new m(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;const r=this._edges.get(t);if(!r)throw new m(`Graph.opposite: could not find the "${t}" edge in the graph.`);const i=r.source.key,n=r.target.key;if(e===i)return n;if(e===n)return i;throw new m(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${i}, ${n}).`)}hasExtremity(e,t){e=""+e,t=""+t;const r=this._edges.get(e);if(!r)throw new m(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return r.source.key===t||r.target.key===t}isUndirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new m(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new m(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;const t=this._edges.get(e);if(!t)throw new m(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return Li(this,e,t).key}mergeNode(e,t){if(t&&!x(t))throw new A(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let r=this._nodes.get(e);return r?(t&&(B(r.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:r.attributes,data:t})),[e,!1]):(r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&typeof t!="function")throw new A(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let r=this._nodes.get(e);if(r){if(t){const n=r.attributes;r.attributes=t(n),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:r.attributes})}return[e,!1]}const i=t?t({}):{};return r=new this.NodeDataClass(e,i),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:i}),[e,!0]}dropNode(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new m(`Graph.dropNode: could not find the "${e}" node in the graph.`);let r;if(this.type!=="undirected"){for(const i in t.out){r=t.out[i];do fe(this,r),r=r.next;while(r)}for(const i in t.in){r=t.in[i];do fe(this,r),r=r.next;while(r)}}if(this.type!=="directed")for(const i in t.undirected){r=t.undirected[i];do fe(this,r),r=r.next;while(r)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(arguments.length>1){const r=""+arguments[0],i=""+arguments[1];if(t=V(this,r,i,this.type),!t)throw new m(`Graph.dropEdge: could not find the "${r}" -> "${i}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new m(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return fe(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new G("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new G("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");e=""+e,t=""+t;const r=V(this,e,t,"directed");if(!r)throw new m(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return fe(this,r),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new G("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new G("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const r=V(this,e,t,"undirected");if(!r)throw new m(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return fe(this,r),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),t.done!==!0;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if(typeof t!="function")throw new A("Graph.updateAttribute: updater should be a function.");const r=this._attributes[e];return this._attributes[e]=t(r),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!x(e))throw new A("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!x(e))throw new A("Graph.mergeAttributes: provided attributes are not a plain object.");return B(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if(typeof e!="function")throw new A("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if(typeof e!="function")throw new A("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!Lt(t))throw new A("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._nodes.values();let i,n;for(;i=r.next(),i.done!==!0;)n=i.value,n.attributes=e(n.key,n.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if(typeof e!="function")throw new A("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!Lt(t))throw new A("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._edges.values();let i,n,s,u;for(;i=r.next(),i.done!==!0;)n=i.value,s=n.source,u=n.target,n.attributes=e(n.key,n.attributes,s.key,u.key,s.attributes,u.attributes,n.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if(typeof e!="function")throw new A("Graph.forEachAdjacencyEntry: expecting a callback.");Re(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new A("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");Re(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if(typeof e!="function")throw new A("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");Re(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new A("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");Re(!1,!0,!0,this,e)}nodes(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):Dt(this._nodes.keys(),this._nodes.size)}forEachNode(e){if(typeof e!="function")throw new A("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();let r,i;for(;r=t.next(),r.done!==!0;)i=r.value,e(i.key,i.attributes)}findNode(e){if(typeof e!="function")throw new A("Graph.findNode: expecting a callback.");const t=this._nodes.values();let r,i;for(;r=t.next(),r.done!==!0;)if(i=r.value,e(i.key,i.attributes))return i.key}mapNodes(e){if(typeof e!="function")throw new A("Graph.mapNode: expecting a callback.");const t=this._nodes.values();let r,i;const n=new Array(this.order);let s=0;for(;r=t.next(),r.done!==!0;)i=r.value,n[s++]=e(i.key,i.attributes);return n}someNode(e){if(typeof e!="function")throw new A("Graph.someNode: expecting a callback.");const t=this._nodes.values();let r,i;for(;r=t.next(),r.done!==!0;)if(i=r.value,e(i.key,i.attributes))return!0;return!1}everyNode(e){if(typeof e!="function")throw new A("Graph.everyNode: expecting a callback.");const t=this._nodes.values();let r,i;for(;r=t.next(),r.done!==!0;)if(i=r.value,!e(i.key,i.attributes))return!1;return!0}filterNodes(e){if(typeof e!="function")throw new A("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();let r,i;const n=[];for(;r=t.next(),r.done!==!0;)i=r.value,e(i.key,i.attributes)&&n.push(i.key);return n}reduceNodes(e,t){if(typeof e!="function")throw new A("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new A("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let r=t;const i=this._nodes.values();let n,s;for(;n=i.next(),n.done!==!0;)s=n.value,r=e(r,s.key,s.attributes);return r}nodeEntries(){const e=this._nodes.values();return new Y(()=>{const t=e.next();if(t.done)return t;const r=t.value;return{value:{node:r.key,attributes:r.attributes},done:!1}})}export(){const e=new Array(this._nodes.size);let t=0;this._nodes.forEach((i,n)=>{e[t++]=vi(n,i)});const r=new Array(this._edges.size);return t=0,this._edges.forEach((i,n)=>{r[t++]=Ai(this.type,n,i)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:r}}import(e,t=!1){if(e instanceof W)return e.forEachNode((d,a)=>{t?this.mergeNode(d,a):this.addNode(d,a)}),e.forEachEdge((d,a,c,f,g,b,$)=>{t?$?this.mergeUndirectedEdgeWithKey(d,c,f,a):this.mergeDirectedEdgeWithKey(d,c,f,a):$?this.addUndirectedEdgeWithKey(d,c,f,a):this.addDirectedEdgeWithKey(d,c,f,a)}),this;if(!x(e))throw new A("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!x(e.attributes))throw new A("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let r,i,n,s,u;if(e.nodes){if(n=e.nodes,!Array.isArray(n))throw new A("Graph.import: invalid nodes. Expecting an array.");for(r=0,i=n.length;r<i;r++){s=n[r],_i(s);const{key:d,attributes:a}=s;t?this.mergeNode(d,a):this.addNode(d,a)}}if(e.edges){let d=!1;if(this.type==="undirected"&&(d=!0),n=e.edges,!Array.isArray(n))throw new A("Graph.import: invalid edges. Expecting an array.");for(r=0,i=n.length;r<i;r++){u=n[r],Gi(u);const{source:a,target:c,attributes:f,undirected:g=d}=u;let b;"key"in u?(b=t?g?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:g?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,b.call(this,u.key,a,c,f)):(b=t?g?this.mergeUndirectedEdge:this.mergeDirectedEdge:g?this.addUndirectedEdge:this.addDirectedEdge,b.call(this,a,c,f))}}return this}nullCopy(e){const t=new W(B({},this._options,e));return t.replaceAttributes(B({},this.getAttributes())),t}emptyCopy(e){const t=this.nullCopy(e);return this._nodes.forEach((r,i)=>{const n=B({},r.attributes);r=new t.NodeDataClass(i,n),t._nodes.set(i,r)}),t}copy(e){if(e=e||{},typeof e.type=="string"&&e.type!==this.type&&e.type!=="mixed")throw new G(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if(typeof e.multi=="boolean"&&e.multi!==this.multi&&e.multi!==!0)throw new G("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof e.allowSelfLoops=="boolean"&&e.allowSelfLoops!==this.allowSelfLoops&&e.allowSelfLoops!==!0)throw new G("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const t=this.emptyCopy(e),r=this._edges.values();let i,n;for(;i=r.next(),i.done!==!0;)n=i.value,Wt(t,"copy",!1,n.undirected,n.key,n.source.key,n.target.key,B({},n.attributes));return t}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const e={};this._nodes.forEach((n,s)=>{e[s]=n.attributes});const t={},r={};this._edges.forEach((n,s)=>{const u=n.undirected?"--":"->";let d="",a=n.source.key,c=n.target.key,f;n.undirected&&a>c&&(f=a,a=c,c=f);const g=`(${a})${u}(${c})`;s.startsWith("geid_")?this.multi&&(typeof r[g]>"u"?r[g]=0:r[g]++,d+=`${r[g]}. `):d+=`[${s}]: `,d+=g,t[d]=n.attributes});const i={};for(const n in this)this.hasOwnProperty(n)&&!Ft.has(n)&&typeof this[n]!="function"&&typeof n!="symbol"&&(i[n]=this[n]);return i.attributes=this._attributes,i.nodes=e,i.edges=t,Z(i,"constructor",this.constructor),i}}typeof Symbol<"u"&&(W.prototype[Symbol.for("nodejs.util.inspect.custom")]=W.prototype.inspect),Si.forEach(o=>{["add","merge","update"].forEach(e=>{const t=o.name(e),r=e==="add"?Wt:Ui;o.generateKey?W.prototype[t]=function(i,n,s){return r(this,t,!0,(o.type||this.type)==="undirected",null,i,n,s,e==="update")}:W.prototype[t]=function(i,n,s,u){return r(this,t,!1,(o.type||this.type)==="undirected",i,n,s,u,e==="update")}})}),Wr(W),Jr(W),fi(W),Ei(W);let zt=class extends W{constructor(e){const t=B({type:"directed"},e);if("multi"in t&&t.multi!==!1)throw new A("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="directed")throw new A('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}},qt=class extends W{constructor(e){const t=B({type:"undirected"},e);if("multi"in t&&t.multi!==!1)throw new A("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="undirected")throw new A('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}};class Pt extends W{constructor(e){const t=B({multi:!0},e);if("multi"in t&&t.multi!==!0)throw new A("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class Kt extends W{constructor(e){const t=B({type:"directed",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new A("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="directed")throw new A('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class Bt extends W{constructor(e){const t=B({type:"undirected",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new A("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="undirected")throw new A('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function le(o){o.from=function(e,t){const r=B({},e.options,t),i=new o(r);return i.import(e),i}}le(W),le(zt),le(qt),le(Pt),le(Kt),le(Bt),W.Graph=W,W.DirectedGraph=zt,W.UndirectedGraph=qt,W.MultiGraph=Pt,W.MultiDirectedGraph=Kt,W.MultiUndirectedGraph=Bt,W.InvalidArgumentsGraphError=A,W.NotFoundGraphError=m,W.UsageGraphError=G;var M={},Xe,xt;function ee(){return xt||(xt=1,Xe=function(e){return e!==null&&typeof e=="object"&&typeof e.addUndirectedEdgeWithKey=="function"&&typeof e.dropNode=="function"&&typeof e.multi=="boolean"}),Xe}var Me={},Ht;function Yt(){return Ht||(Ht=1,Me.copyNode=function(o,e,t){return t=Object.assign({},t),o.addNode(e,t)}),Me}var pe={},Vt;function ge(){return Vt||(Vt=1,pe.addEdge=function(e,t,r,i,n,s){return t?r==null?e.addUndirectedEdge(i,n,s):e.addUndirectedEdgeWithKey(r,i,n,s):r==null?e.addDirectedEdge(i,n,s):e.addDirectedEdgeWithKey(r,i,n,s)},pe.copyEdge=function(e,t,r,i,n,s){return s=Object.assign({},s),t?r==null?e.addUndirectedEdge(i,n,s):e.addUndirectedEdgeWithKey(r,i,n,s):r==null?e.addDirectedEdge(i,n,s):e.addDirectedEdgeWithKey(r,i,n,s)},pe.mergeEdge=function(e,t,r,i,n,s){return t?r==null?e.mergeUndirectedEdge(i,n,s):e.mergeUndirectedEdgeWithKey(r,i,n,s):r==null?e.mergeDirectedEdge(i,n,s):e.mergeDirectedEdgeWithKey(r,i,n,s)},pe.updateEdge=function(e,t,r,i,n,s){return t?r==null?e.updateUndirectedEdge(i,n,s):e.updateUndirectedEdgeWithKey(r,i,n,s):r==null?e.updateDirectedEdge(i,n,s):e.updateDirectedEdgeWithKey(r,i,n,s)}),pe}var et,Zt;function Ri(){if(Zt)return et;Zt=1;var o=ee(),e=Yt().copyNode,t=ge().copyEdge;return et=function(i,n){if(!o(i)||!o(n))throw new Error("graphology-operators/disjoint-union: invalid graph.");if(i.multi!==n.multi)throw new Error("graphology-operators/disjoint-union: both graph should be simple or multi.");var s=i.nullCopy();s.mergeAttributes(i.getAttributes());var u={},d={},a=0;return i.forEachNode(function(c,f){u[c]=a,e(s,a,f),a++}),n.forEachNode(function(c,f){d[c]=a,e(s,a,f),a++}),a=0,i.forEachEdge(function(c,f,g,b,$,U,C){t(s,C,a++,u[g],u[b],b,f)}),n.forEachEdge(function(c,f,g,b,$,U,C){t(s,C,a++,d[g],d[b],b,f)}),s},et}var tt,Jt;function Oi(){if(Jt)return tt;Jt=1;var o=ee(),e=ge().copyEdge;return tt=function(r){if(!o(r))throw new Error("graphology-operators/reverse: invalid graph.");var i=r.emptyCopy();return r.forEachEdge(function(n,s,u,d,a,c,f){f?e(i,!0,n,u,d,s):e(i,!1,n,d,u,s)}),i},tt}var rt,Qt;function Ni(){if(Qt)return rt;Qt=1;var o=ee(),e=Yt().copyNode,t=ge().copyEdge;return rt=function(i,n){if(!o(i))throw new Error("graphology-operators/subgraph: invalid graph instance.");var s=i.nullCopy(),u=n;if(Array.isArray(n)){if(n.length===0)return s;n=new Set(n)}if(n instanceof Set){if(n.size===0)return s;u=function(a){return n.has(a)};var d=n;n=new Set,d.forEach(function(a){n.add(""+a)})}if(typeof u!="function")throw new Error("graphology-operators/subgraph: invalid nodes. Expecting an array or a set or a filtering function.");if(typeof n=="function"){if(i.forEachNode(function(a,c){u(a,c)&&e(s,a,c)}),s.order===0)return s}else n.forEach(function(a){if(!i.hasNode(a))throw new Error('graphology-operators/subgraph: the "'+a+'" node was not found in the graph.');e(s,a,i.getNodeAttributes(a))});return i.forEachEdge(function(a,c,f,g,b,$,U){u(f,b)&&(g!==f&&!u(g,$)||t(s,U,a,f,g,c))}),s},rt}var it,Xt;function Ci(){if(Xt)return it;Xt=1;var o=ee(),e=ge().copyEdge;return it=function(r,i){if(!o(r))throw new Error("graphology-operators/to-directed: expecting a valid graphology instance.");typeof i=="function"&&(i={mergeEdge:i}),i=i||{};var n=typeof i.mergeEdge=="function"?i.mergeEdge:null;if(r.type==="directed")return r.copy();var s=r.emptyCopy({type:"directed"});return r.forEachDirectedEdge(function(u,d,a,c){e(s,!1,u,a,c,d)}),r.forEachUndirectedEdge(function(u,d,a,c){var f=!r.multi&&r.type==="mixed"&&s.edge(a,c),g=!r.multi&&r.type==="mixed"&&s.edge(c,a);f?s.replaceEdgeAttributes(f,n(s.getEdgeAttributes(f),d)):e(s,!1,null,a,c,d),a!==c&&(g?s.replaceEdgeAttributes(g,n(s.getEdgeAttributes(g),d)):e(s,!1,null,c,a,d))}),s},it}var nt,Mt;function Ii(){if(Mt)return nt;Mt=1;var o=ee();return nt=function(t){if(!o(t))throw new Error("graphology-operators/to-mixed: expecting a valid graphology instance.");return t.copy({type:"mixed"})},nt}var ot,er;function ji(){if(er)return ot;er=1;var o=ee();return ot=function(t){if(!o(t))throw new Error("graphology-operators/to-multi: expecting a valid graphology instance.");return t.copy({multi:!0})},ot}var st,tr;function Fi(){if(tr)return st;tr=1;var o=ee(),e=ge().copyEdge;return st=function(r,i){if(!o(r))throw new Error("graphology-operators/to-simple: expecting a valid graphology instance.");typeof i=="function"&&(i={mergeEdge:i}),i=i||{};var n=typeof i.mergeEdge=="function"?i.mergeEdge:null;if(!r.multi)return r.copy();var s=r.emptyCopy({multi:!1});return r.forEachEdge(function(u,d,a,c,f,g,b){var $=b?s.undirectedEdge(a,c):s.directedEdge(a,c);if($){n&&s.replaceEdgeAttributes($,n(s.getEdgeAttributes($),d));return}e(s,b,u,a,c,d)}),s},st}var ut,rr;function Ti(){if(rr)return ut;rr=1;var o=ee(),e=ge().copyEdge;return ut=function(r,i){if(!o(r))throw new Error("graphology-operators/to-undirected: expecting a valid graphology instance.");typeof i=="function"&&(i={mergeEdge:i}),i=i||{};var n=typeof i.mergeEdge=="function"?i.mergeEdge:null;if(r.type==="undirected")return r.copy();var s=r.emptyCopy({type:"undirected"});return r.forEachUndirectedEdge(function(u,d,a,c){e(s,!0,u,a,c,d)}),r.forEachDirectedEdge(function(u,d,a,c){if(!r.multi){var f=s.edge(a,c);if(f){n&&s.replaceEdgeAttributes(f,n(s.getEdgeAttributes(f),d));return}}e(s,!0,null,a,c,d)}),s},ut}var at,ir;function Wi(){if(ir)return at;ir=1;var o=ee();return at=function(t,r){if(!o(t)||!o(r))throw new Error("graphology-operators/union: invalid graph.");if(t.multi!==r.multi)throw new Error("graphology-operators/union: both graph should be simple or multi.");var i=t.copy();return i.import(r,!0),i},at}var nr;function zi(){return nr||(nr=1,M.disjointUnion=Ri(),M.reverse=Oi(),M.subgraph=Ni(),M.toDirected=Ci(),M.toMixed=Ii(),M.toMulti=ji(),M.toSimple=Fi(),M.toUndirected=Ti(),M.union=Wi()),M}zi();function qi(o){o.prototype.updateSelectedNodesName=function(e){this.updateSelectedNodesAttributes({label:e})},o.prototype.updateSelectedNodesInfo=function(e){this.updateSelectedNodesAttributes({desc:e})},o.prototype.setDefaultNodeWeight=function(e=1){this.updateEachNodeAttributes((t,r)=>({...r,weight:e}))},o.prototype.getNodesForD3=function(){return this.nodes().map(e=>({...this.getNodeAttributes(e),id:Number(e)}))},o.prototype.selectNode=function(e){this.setNodeAttribute(e,"selected",!0)},o.prototype.deselectNode=function(e){this.setNodeAttribute(e,"selected",!1)},o.prototype.toggleNodeSelection=function(e){if((this.getNodeAttribute(e,"selected")||0)>0)this.setNodeAttribute(e,"selected",0);else{let r=0;this.forEachNode((i,n)=>{n.selected>r&&(r=n.selected)}),this.setNodeAttribute(e,"selected",r+1)}},o.prototype.getSelectedNodes=function(){return this.filterNodes((e,t)=>t.selected>0).sort((e,t)=>this.getNodeAttribute(e,"selected")-this.getNodeAttribute(t,"selected"))},o.prototype.updateSelectedNodesColor=function(e,t,r){!e||!t||!r?e?this.updateSelectedNodesAttributes({color:e}):t?this.updateSelectedNodesAttributes({stroke:t}):r&&this.updateSelectedNodesAttributes({labelColor:r}):this.updateSelectedNodesAttributes({color:e,stroke:t,labelColor:r})},o.prototype.updateSelectedNodesAttributes=function(e){this.getSelectedNodes().forEach(t=>{this.mergeNodeAttributes(t,e)})},o.prototype.connectSelectedNodes=function(e,t="directed"){const r=this.getSelectedNodes();if(!(r.length<1)){if(r.length>1)for(let i=0;i<r.length;i++)for(let n=i+1;n<r.length;n++){const s=r[i],u=r[n],d={color:e,selected:!1};this.type==="mixed"?t==="undirected"?this.mergeUndirectedEdge(s,u,d):this.mergeDirectedEdge(s,u,d):this.mergeEdge(s,u,d)}else if(this.allowSelfLoops){const i=r[0],n={color:e,selected:!1};t==="undirected"?this.mergeUndirectedEdge(i,i,n):this.mergeDirectedEdge(i,i,n)}}},o.prototype.connectSelectedNodesInOrder=function(e,t="directed"){const r=this.getSelectedNodes();for(let i=0;i<r.length-1;i++){const n=r[i],s=r[i+1],u={color:e,selected:!1};t==="undirected"?this.mergeUndirectedEdge(n,s,u):this.mergeDirectedEdge(n,s,u)}}}function Pi(o){o.prototype.setDefaultEdgeWeight=function(e=1){this.updateEachEdgeAttributes((t,r)=>({...r,weight:e}))},o.prototype.getEdgeSourceTarget=function(e){return[this.source(e),this.target(e)]},o.prototype.updateSelectedEdgesName=function(e){this.updateSelectedEdgesAttributes({label:e})},o.prototype.updateSelectedEdgesInfo=function(e){this.updateSelectedEdgesAttributes({desc:e})},o.prototype.getEdgesForD3=function(){return this.edges().map(e=>{const{source:t,target:r}=this.getEdgeAttributes(e);return{source:t,target:r}})},o.prototype.selectEdge=function(e){this.setEdgeAttribute(e,"selected",!0)},o.prototype.deselectEdge=function(e){this.setEdgeAttribute(e,"selected",!1)},o.prototype.toggleEdgeSelection=function(e){if((this.getEdgeAttribute(e,"selected")||0)>0)this.setEdgeAttribute(e,"selected",0);else{let r=0;this.forEachEdge((i,n)=>{n.selected>r&&(r=n.selected)}),this.setEdgeAttribute(e,"selected",r+1)}},o.prototype.getSelectedEdges=function(){return this.filterEdges((e,t)=>t.selected>0).sort((e,t)=>this.getEdgeAttribute(e,"selected")-this.getEdgeAttribute(t,"selected"))},o.prototype.updateSelectedEdgesAttributes=function(e){this.getSelectedEdges().forEach(t=>{this.mergeEdgeAttributes(t,e)})},o.prototype.updateSelectedEdgesColor=function(e,t){const r={...e&&{color:e},...t&&{labelColor:t}};this.updateSelectedEdgesAttributes(r)},o.prototype.updateSelectedEdgesName=function(e){this.updateSelectedEdgesAttributes({label:e})},o.prototype.updateSelectedEdgesInfo=function(e){this.updateSelectedEdgesAttributes({desc:e})}}function Ki(o){o.prototype.addFace=function(e,t){const r=e.join("_");t={...t,key:r,id:this._faces.size,nodes:e,color:this.colors.face_color,labelColor:this.colors.label_color};var i=new Bi(r,e,t);this._faces.set(r,i)},o.prototype.faces=function(){return Array.from(this._faces.keys())},o.prototype.findFace=function(e){return e.sort(),e.join("_")},o.prototype.dropFace=function(e){this._faces.has(e)&&this._faces.delete(e)},o.prototype.hasFace=function(e){return this._faces.has(e)},o.prototype.faceNodeNeighbors=function(e){const t=[];return this.forEachFace((r,i)=>{i.nodes.includes(e)&&t.push(r)}),t},o.prototype.faceEdgeNeighbors=function(e){const{source:t,target:r}=this.getEdgeAttributes(e),i=[];return this.forEachFace((n,s)=>{s.nodes.includes(""+t)&&s.nodes.includes(""+r)&&i.push(n)}),i},o.prototype.forEachFace=function(e){for(const t of this._faces.values())e(t.key,t.attributes)},o.prototype.setFaceAttribute=function(e,t,r){this._faces.get(e).attributes[t]=r},o.prototype.getFaceAttribute=function(e,t){return this._faces.get(e).attributes[t]},o.prototype.getFaceAttributes=function(e){return this._faces.get(e).attributes},o.prototype.selectFace=function(e){this.setFaceAttribute(e,"selected",!0)},o.prototype.deselectFace=function(e){this.setFaceAttribute(e,"selected",!1)},o.prototype.toggleFaceSelection=function(e){if((this.getFaceAttribute(e,"selected")||0)>0)this.setFaceAttribute(e,"selected",0);else{let r=0;this.forEachFace((i,n)=>{n.selected>r&&(r=n.selected)}),this.setFaceAttribute(e,"selected",r+1)}},o.prototype.getSelectedFaces=function(){return this.faces().filter(e=>this.getFaceAttributes(e).selected>0).sort((e,t)=>this.getFaceAttribute(e,"selected")-this.getFaceAttribute(t,"selected"))},o.prototype.updateSelectedFacesAttributes=function(e){this.getSelectedFaces().forEach(t=>{const r=this.getFaceAttributes(t);this._faces.get(t).attributes={...r,...e}})},o.prototype.updateSelectedFacesColor=function(e,t){const r={...e&&{color:e},...t&&{labelColor:t}};this.updateSelectedFacesAttributes(r)},o.prototype.updateSelectedFacesName=function(e){this.updateSelectedFacesAttributes({label:e})},o.prototype.updateSelectedFacesInfo=function(e){this.updateSelectedFacesAttributes({desc:e})},o.prototype.updateSelectedFacesWeight=function(e){this.updateSelectedFacesAttributes({weight:e})},o.prototype.deleteSelectedFaces=function(){this.getSelectedFaces().forEach(e=>this.dropFace(e))}}class Bi{constructor(e,t,r){this.key=e,this.attributes=r,this.nodes=t}}function or(o,e=3){const t="abcdefghijklmnopqrstuvwxyz",r=[];function i(s,u,d){if(d===0){r.push(s);return}for(let a=u;a<t.length;a++)if(i(s+t[a],a+1,d-1),r.length>o)return}let n=1;for(;r.length<=o&&n<=e;)i("",0,n),n++;return r[o]||null}class se extends W{constructor(e){super(e),this.isCustom=!0,this.defaultColors={edge_color:"#4682b4",label_color:"#000000",node_color:"#ffffff",face_color:"#4682b455",stroke_color:"#4682b4"},this.colors=this.defaultColors,this._faces=new Map,this.events()}events(){this.on("nodeAdded",({key:e})=>{const t=this.getNodeAttributes(e);t.id||this.setNodeAttribute(e,"id",+e),t.label===void 0&&this.setNodeAttribute(e,"label",or(t.id)),t.weight===void 0&&this.setNodeAttribute(e,"weight",void 0),t.color===void 0&&this.setNodeAttribute(e,"color",this.colors.node_color),t.stroke===void 0&&this.setNodeAttribute(e,"stroke",this.colors.stroke_color),t.labelColor===void 0&&this.setNodeAttribute(e,"labelColor",this.colors.label_color),t.selected===void 0&&this.setNodeAttribute(e,"selected",!1),t.size===void 0&&this.setNodeAttribute(e,"size",.25),t.magnitude===void 0&&this.setNodeAttribute(e,"magnitude",1),t.desc===void 0&&this.setNodeAttribute(e,"desc",{})}),this.on("edgeAdded",({key:e,source:t,target:r})=>{const i=this.getEdgeAttributes(e);i.id||this.setEdgeAttribute(e,"id",this.size-1),i.label===void 0&&this.setEdgeAttribute(e,"label",or(i.id)),i.weight===void 0&&this.setEdgeAttribute(e,"weight",void 0),i.color===void 0&&this.setEdgeAttribute(e,"color",this.colors.edge_color),i.labelColor===void 0&&this.setEdgeAttribute(e,"labelColor",this.colors.label_color),i.source||this.setEdgeAttribute(e,"source",Number(t)),i.target||this.setEdgeAttribute(e,"target",Number(r)),i.selected===void 0&&this.setEdgeAttribute(e,"selected",!1),i.desc===void 0&&this.setEdgeAttribute(e,"desc",{})})}validateSettings(e={}){return Object.fromEntries(Object.keys(this.defaultColors).map(t=>[t,t in e?e[t]:this.defaultColors[t]]))}nullCopy(e){var t=new se(Oe({},this._options,e));return t.replaceAttributes(Oe({},this.getAttributes())),t}deselectAll(){this.updateEachNodeAttributes((e,t)=>({...t,selected:0})),this.updateEachEdgeAttributes((e,t)=>({...t,selected:!1}))}deleteSelected(){this.getSelectedEdges().forEach(e=>this.dropEdge(e)),this.getSelectedNodes().forEach(e=>this.dropNode(e))}updateSelectedName(e){this.updateSelectedNodesAttributes({label:e}),this.updateSelectedEdgesAttributes({label:e}),this.updateSelectedFacesAttributes({label:e})}updateSelectedInfo(e){this.updateSelectedNodesAttributes({desc:e}),this.updateSelectedEdgesAttributes({desc:e}),this.updateSelectedFacesAttributes({desc:e})}updateSelectedWeight(e){this.updateSelectedNodesAttributes({weight:e}),this.updateSelectedEdgesAttributes({weight:e}),this.updateSelectedFacesAttributes({weight:e})}selectPath(e){this.deselectAll(),e.forEach(t=>{this.hasNode(t)&&this.selectNode(t)});for(let t=0;t<e.length-1;t++){const r=e[t],i=e[t+1];if(this.hasEdge(r,i)){const n=this.edge(r,i);this.selectEdge(n)}}}replace(e){this.clear(),this.import(e.export())}dropNode(e){const t=this.faceNodeNeighbors(e);t.length&&t.map(r=>{this.dropFace(r)}),super.dropNode(e)}dropEdge(e){var t;if(arguments.length>1){var r=""+arguments[0],i=""+arguments[1];this.findEdge(r,i,s=>{t=s})}else t=e;const n=this.faceEdgeNeighbors(t);n.length&&n.map(s=>{this.dropFace(s)}),super.dropEdge(t)}export(){const e=super.export();e.attributes.selected=!1;var t=new Array(this._faces.size),r=0;return this._faces.forEach(function(i,n){t[r++]=Hi(n,i)}),e.faces=t,e}import(e){const t=super.import(e);if(typeof e.faces=="function")e.forEachFace((r,i)=>{t.addFace(i.nodes,i)});else for(const r of e.faces)t.addFace(r.nodes,r.attributes);return t}subgraph(e){const t=this.nullCopy();if(!e||Array.isArray(e)&&e.length===0||e instanceof Set&&e.size===0)return t;const r=new Set(e);for(const i of r)t.addNode(i,this.getNodeAttributes(i));return this.forEachEdge((i,n,s,u,d,a,c)=>{r.has(s)&&r.has(u)&&(c?t.addUndirectedEdgeWithKey(i,s,u,n):t.addDirectedEdgeWithKey(i,s,u,n))}),this.forEachFace((i,n)=>{const s=n.nodes||[];console.log(s),s.every(u=>r.has(u)||r.has(""+u))&&t.addFace(n.nodes,n)}),t}mergeWith(e){if(this.multi!==e.multi)throw new Error("graphology-operators/disjoint-union: both graph should be simple or multi.");this.mergeAttributes(this.getAttributes());var t={},r=Math.max(...this.nodes())+1;e.forEachNode((i,n)=>{t[i]=r,this.addNode(r,{...n,id:r}),r++}),r=Math.max(...this.edges())+1,e.forEachEdge((i,n,s,u,d,a,c)=>{c?this.addUndirectedEdge(t[s],t[u],{...n,id:r++,source:t[s],target:t[u]}):this.addDirectedEdge(t[s],t[u],{...n,id:r++})}),r=Math.max(...this.faces())+1,e.forEachFace((i,n)=>{const s=n.nodes.map(u=>t[u]);this.addFace(s,{...n,id:r++,nodes:s})})}clear(){this._faces.clear(),this._edges.clear(),this._nodes.clear()}}function xi(){for(var o=arguments[0],e=1,t=arguments.length;e<t;e++)if(arguments[e])for(var r in arguments[e])o[r]=arguments[e][r];return o}var Oe=xi;typeof Object.assign=="function"&&(Oe=Object.assign);function Hi(o,e){var t={key:o,nodes:e.nodes};return Object.keys(e.attributes).length&&(t.attributes=Oe({},e.attributes)),t}qi(se),Pi(se),Ki(se);class Yi extends se{constructor(e={}){const t=Object.assign({type:"directed"},e);if("multi"in t&&t.multi!==!1)throw new InvalidArgumentsGraphError("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="directed")throw new InvalidArgumentsGraphError(`DirectedGraph.from: inconsistent "${t.type}" type in given options!`);super(t)}}class Vi extends se{constructor(e={}){const t=Object.assign({type:"undirected"},e);if("multi"in t&&t.multi!==!1)throw new InvalidArgumentsGraphError("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="undirected")throw new InvalidArgumentsGraphError(`UndirectedGraph.from: inconsistent "${t.type}" type in given options!`);super(t)}}var ye={},dt,sr;function Ne(){return sr||(sr=1,dt=function(e){return e!==null&&typeof e=="function"&&typeof e.prototype=="object"&&typeof e.prototype.addUndirectedEdgeWithKey=="function"&&typeof e.prototype.dropNode=="function"}),dt}var ct,ur;function Zi(){if(ur)return ct;ur=1;var o=Ne();return ct=function(t,r){if(!o(t))throw new Error("graphology-generators/classic/complete: invalid Graph constructor.");var i=new t,n,s;for(n=0;n<r;n++)i.addNode(n);for(n=0;n<r;n++)for(s=n+1;s<r;s++)i.type!=="directed"&&i.addUndirectedEdge(n,s),i.type!=="undirected"&&(i.addDirectedEdge(n,s),i.addDirectedEdge(s,n));return i},ct}var ht,ar;function Ji(){if(ar)return ht;ar=1;var o=Ne();return ht=function(t,r){if(!o(t))throw new Error("graphology-generators/classic/empty: invalid Graph constructor.");var i=new t,n;for(n=0;n<r;n++)i.addNode(n);return i},ht}var ft,dr;function Qi(){if(dr)return ft;dr=1;var o=Ne();return ft=function(t,r){if(!o(t))throw new Error("graphology-generators/classic/ladder: invalid Graph constructor.");var i=new t,n;for(n=0;n<r-1;n++)i.mergeEdge(n,n+1);for(n=r;n<r*2-1;n++)i.mergeEdge(n,n+1);for(n=0;n<r;n++)i.addEdge(n,n+r);return i},ft}var lt,cr;function Xi(){if(cr)return lt;cr=1;var o=Ne();return lt=function(t,r){if(!o(t))throw new Error("graphology-generators/classic/path: invalid Graph constructor.");for(var i=new t,n=0;n<r-1;n++)i.mergeEdge(n,n+1);return i},lt}var hr;function Mi(){return hr||(hr=1,ye.complete=Zi(),ye.empty=Ji(),ye.ladder=Qi(),ye.path=Xi()),ye}var en=Mi(),Ge={},fr;function tn(){if(fr)return Ge;fr=1;function o(r){return typeof r!="number"||isNaN(r)?1:r}function e(r,i){var n={},s=function(a){return typeof a>"u"?i:a};typeof i=="function"&&(s=i);var u=function(a){return s(a[r])},d=function(){return s(void 0)};return typeof r=="string"?(n.fromAttributes=u,n.fromGraph=function(a,c){return u(a.getNodeAttributes(c))},n.fromEntry=function(a,c){return u(c)}):typeof r=="function"?(n.fromAttributes=function(){throw new Error("graphology-utils/getters/createNodeValueGetter: irrelevant usage.")},n.fromGraph=function(a,c){return s(r(c,a.getNodeAttributes(c)))},n.fromEntry=function(a,c){return s(r(a,c))}):(n.fromAttributes=d,n.fromGraph=d,n.fromEntry=d),n}function t(r,i){var n={},s=function(a){return typeof a>"u"?i:a};typeof i=="function"&&(s=i);var u=function(a){return s(a[r])},d=function(){return s(void 0)};return typeof r=="string"?(n.fromAttributes=u,n.fromGraph=function(a,c){return u(a.getEdgeAttributes(c))},n.fromEntry=function(a,c){return u(c)},n.fromPartialEntry=n.fromEntry,n.fromMinimalEntry=n.fromEntry):typeof r=="function"?(n.fromAttributes=function(){throw new Error("graphology-utils/getters/createEdgeValueGetter: irrelevant usage.")},n.fromGraph=function(a,c){var f=a.extremities(c);return s(r(c,a.getEdgeAttributes(c),f[0],f[1],a.getNodeAttributes(f[0]),a.getNodeAttributes(f[1]),a.isUndirected(c)))},n.fromEntry=function(a,c,f,g,b,$,U){return s(r(a,c,f,g,b,$,U))},n.fromPartialEntry=function(a,c,f,g){return s(r(a,c,f,g))},n.fromMinimalEntry=function(a,c){return s(r(a,c))}):(n.fromAttributes=d,n.fromGraph=d,n.fromEntry=d,n.fromMinimalEntry=d),n}return Ge.createNodeValueGetter=e,Ge.createEdgeValueGetter=t,Ge.createEdgeWeightGetter=function(r){return t(r,o)},Ge}var pt,lr;function rn(){if(lr)return pt;lr=1;var o=0,e=1,t=2,r=3,i=4,n=5,s=6,u=7,d=8,a=9,c=0,f=1,g=2,b=0,$=1,U=2,C=3,I=4,N=5,z=6,w=7,y=8,v=3,_=10,L=3,R=9,O=10;return pt=function(j,h,we){var wt,E,l,q,K,ue,be,H,k,bt,te=h.length,cn=we.length,$e=j.adjustSizes,hn=j.barnesHutTheta*j.barnesHutTheta,Ce,P,F,T,oe,S,D,p=[];for(l=0;l<te;l+=_)h[l+i]=h[l+t],h[l+n]=h[l+r],h[l+t]=0,h[l+r]=0;if(j.outboundAttractionDistribution){for(Ce=0,l=0;l<te;l+=_)Ce+=h[l+s];Ce/=te/_}if(j.barnesHutOptimize){var ae=1/0,me=-1/0,de=1/0,Ee=-1/0,Q,ve,mt;for(l=0;l<te;l+=_)ae=Math.min(ae,h[l+o]),me=Math.max(me,h[l+o]),de=Math.min(de,h[l+e]),Ee=Math.max(Ee,h[l+e]);var Ie=me-ae,je=Ee-de;for(Ie>je?(de-=(Ie-je)/2,Ee=de+Ie):(ae-=(je-Ie)/2,me=ae+je),p[0+b]=-1,p[0+$]=(ae+me)/2,p[0+U]=(de+Ee)/2,p[0+C]=Math.max(me-ae,Ee-de),p[0+I]=-1,p[0+N]=-1,p[0+z]=0,p[0+w]=0,p[0+y]=0,wt=1,l=0;l<te;l+=_)for(E=0,mt=v;;)if(p[E+N]>=0){h[l+o]<p[E+$]?h[l+e]<p[E+U]?Q=p[E+N]:Q=p[E+N]+R:h[l+e]<p[E+U]?Q=p[E+N]+R*2:Q=p[E+N]+R*3,p[E+w]=(p[E+w]*p[E+z]+h[l+o]*h[l+s])/(p[E+z]+h[l+s]),p[E+y]=(p[E+y]*p[E+z]+h[l+e]*h[l+s])/(p[E+z]+h[l+s]),p[E+z]+=h[l+s],E=Q;continue}else if(p[E+b]<0){p[E+b]=l;break}else{if(p[E+N]=wt*R,H=p[E+C]/2,k=p[E+N],p[k+b]=-1,p[k+$]=p[E+$]-H,p[k+U]=p[E+U]-H,p[k+C]=H,p[k+I]=k+R,p[k+N]=-1,p[k+z]=0,p[k+w]=0,p[k+y]=0,k+=R,p[k+b]=-1,p[k+$]=p[E+$]-H,p[k+U]=p[E+U]+H,p[k+C]=H,p[k+I]=k+R,p[k+N]=-1,p[k+z]=0,p[k+w]=0,p[k+y]=0,k+=R,p[k+b]=-1,p[k+$]=p[E+$]+H,p[k+U]=p[E+U]-H,p[k+C]=H,p[k+I]=k+R,p[k+N]=-1,p[k+z]=0,p[k+w]=0,p[k+y]=0,k+=R,p[k+b]=-1,p[k+$]=p[E+$]+H,p[k+U]=p[E+U]+H,p[k+C]=H,p[k+I]=p[E+I],p[k+N]=-1,p[k+z]=0,p[k+w]=0,p[k+y]=0,wt+=4,h[p[E+b]+o]<p[E+$]?h[p[E+b]+e]<p[E+U]?Q=p[E+N]:Q=p[E+N]+R:h[p[E+b]+e]<p[E+U]?Q=p[E+N]+R*2:Q=p[E+N]+R*3,p[E+z]=h[p[E+b]+s],p[E+w]=h[p[E+b]+o],p[E+y]=h[p[E+b]+e],p[Q+b]=p[E+b],p[E+b]=-1,h[l+o]<p[E+$]?h[l+e]<p[E+U]?ve=p[E+N]:ve=p[E+N]+R:h[l+e]<p[E+U]?ve=p[E+N]+R*2:ve=p[E+N]+R*3,Q===ve)if(mt--){E=Q;continue}else{mt=v;break}p[ve+b]=l;break}}if(j.barnesHutOptimize)for(P=j.scalingRatio,l=0;l<te;l+=_)for(E=0;;)if(p[E+N]>=0)if(S=Math.pow(h[l+o]-p[E+w],2)+Math.pow(h[l+e]-p[E+y],2),bt=p[E+C],4*bt*bt/S<hn){if(F=h[l+o]-p[E+w],T=h[l+e]-p[E+y],$e===!0?S>0?(D=P*h[l+s]*p[E+z]/S,h[l+t]+=F*D,h[l+r]+=T*D):S<0&&(D=-P*h[l+s]*p[E+z]/Math.sqrt(S),h[l+t]+=F*D,h[l+r]+=T*D):S>0&&(D=P*h[l+s]*p[E+z]/S,h[l+t]+=F*D,h[l+r]+=T*D),E=p[E+I],E<0)break;continue}else{E=p[E+N];continue}else{if(ue=p[E+b],ue>=0&&ue!==l&&(F=h[l+o]-h[ue+o],T=h[l+e]-h[ue+e],S=F*F+T*T,$e===!0?S>0?(D=P*h[l+s]*h[ue+s]/S,h[l+t]+=F*D,h[l+r]+=T*D):S<0&&(D=-P*h[l+s]*h[ue+s]/Math.sqrt(S),h[l+t]+=F*D,h[l+r]+=T*D):S>0&&(D=P*h[l+s]*h[ue+s]/S,h[l+t]+=F*D,h[l+r]+=T*D)),E=p[E+I],E<0)break;continue}else for(P=j.scalingRatio,q=0;q<te;q+=_)for(K=0;K<q;K+=_)F=h[q+o]-h[K+o],T=h[q+e]-h[K+e],$e===!0?(S=Math.sqrt(F*F+T*T)-h[q+d]-h[K+d],S>0?(D=P*h[q+s]*h[K+s]/S/S,h[q+t]+=F*D,h[q+r]+=T*D,h[K+t]-=F*D,h[K+r]-=T*D):S<0&&(D=100*P*h[q+s]*h[K+s],h[q+t]+=F*D,h[q+r]+=T*D,h[K+t]-=F*D,h[K+r]-=T*D)):(S=Math.sqrt(F*F+T*T),S>0&&(D=P*h[q+s]*h[K+s]/S/S,h[q+t]+=F*D,h[q+r]+=T*D,h[K+t]-=F*D,h[K+r]-=T*D));for(k=j.gravity/j.scalingRatio,P=j.scalingRatio,l=0;l<te;l+=_)D=0,F=h[l+o],T=h[l+e],S=Math.sqrt(Math.pow(F,2)+Math.pow(T,2)),j.strongGravityMode?S>0&&(D=P*h[l+s]*k):S>0&&(D=P*h[l+s]*k/S),h[l+t]-=F*D,h[l+r]-=T*D;for(P=1*(j.outboundAttractionDistribution?Ce:1),be=0;be<cn;be+=L)q=we[be+c],K=we[be+f],H=we[be+g],oe=Math.pow(H,j.edgeWeightInfluence),F=h[q+o]-h[K+o],T=h[q+e]-h[K+e],$e===!0?(S=Math.sqrt(F*F+T*T)-h[q+d]-h[K+d],j.linLogMode?j.outboundAttractionDistribution?S>0&&(D=-P*oe*Math.log(1+S)/S/h[q+s]):S>0&&(D=-P*oe*Math.log(1+S)/S):j.outboundAttractionDistribution?S>0&&(D=-P*oe/h[q+s]):S>0&&(D=-P*oe)):(S=Math.sqrt(Math.pow(F,2)+Math.pow(T,2)),j.linLogMode?j.outboundAttractionDistribution?S>0&&(D=-P*oe*Math.log(1+S)/S/h[q+s]):S>0&&(D=-P*oe*Math.log(1+S)/S):j.outboundAttractionDistribution?(S=1,D=-P*oe/h[q+s]):(S=1,D=-P*oe)),S>0&&(h[q+t]+=F*D,h[q+r]+=T*D,h[K+t]-=F*D,h[K+r]-=T*D);var Fe,De,Te,ce,We,ze;if($e===!0)for(l=0;l<te;l+=_)h[l+a]!==1&&(Fe=Math.sqrt(Math.pow(h[l+t],2)+Math.pow(h[l+r],2)),Fe>O&&(h[l+t]=h[l+t]*O/Fe,h[l+r]=h[l+r]*O/Fe),De=h[l+s]*Math.sqrt((h[l+i]-h[l+t])*(h[l+i]-h[l+t])+(h[l+n]-h[l+r])*(h[l+n]-h[l+r])),Te=Math.sqrt((h[l+i]+h[l+t])*(h[l+i]+h[l+t])+(h[l+n]+h[l+r])*(h[l+n]+h[l+r]))/2,ce=.1*Math.log(1+Te)/(1+Math.sqrt(De)),We=h[l+o]+h[l+t]*(ce/j.slowDown),h[l+o]=We,ze=h[l+e]+h[l+r]*(ce/j.slowDown),h[l+e]=ze);else for(l=0;l<te;l+=_)h[l+a]!==1&&(De=h[l+s]*Math.sqrt((h[l+i]-h[l+t])*(h[l+i]-h[l+t])+(h[l+n]-h[l+r])*(h[l+n]-h[l+r])),Te=Math.sqrt((h[l+i]+h[l+t])*(h[l+i]+h[l+t])+(h[l+n]+h[l+r])*(h[l+n]+h[l+r]))/2,ce=h[l+u]*Math.log(1+Te)/(1+Math.sqrt(De)),h[l+u]=Math.min(1,Math.sqrt(ce*(Math.pow(h[l+t],2)+Math.pow(h[l+r],2))/(1+Math.sqrt(De)))),We=h[l+o]+h[l+t]*(ce/j.slowDown),h[l+o]=We,ze=h[l+e]+h[l+r]*(ce/j.slowDown),h[l+e]=ze);return{}},pt}var ne={},pr;function nn(){if(pr)return ne;pr=1;var o=10,e=3;return ne.assign=function(t){t=t||{};var r=Array.prototype.slice.call(arguments).slice(1),i,n,s;for(i=0,s=r.length;i<s;i++)if(r[i])for(n in r[i])t[n]=r[i][n];return t},ne.validateSettings=function(t){return"linLogMode"in t&&typeof t.linLogMode!="boolean"?{message:"the `linLogMode` setting should be a boolean."}:"outboundAttractionDistribution"in t&&typeof t.outboundAttractionDistribution!="boolean"?{message:"the `outboundAttractionDistribution` setting should be a boolean."}:"adjustSizes"in t&&typeof t.adjustSizes!="boolean"?{message:"the `adjustSizes` setting should be a boolean."}:"edgeWeightInfluence"in t&&typeof t.edgeWeightInfluence!="number"?{message:"the `edgeWeightInfluence` setting should be a number."}:"scalingRatio"in t&&!(typeof t.scalingRatio=="number"&&t.scalingRatio>=0)?{message:"the `scalingRatio` setting should be a number >= 0."}:"strongGravityMode"in t&&typeof t.strongGravityMode!="boolean"?{message:"the `strongGravityMode` setting should be a boolean."}:"gravity"in t&&!(typeof t.gravity=="number"&&t.gravity>=0)?{message:"the `gravity` setting should be a number >= 0."}:"slowDown"in t&&!(typeof t.slowDown=="number"||t.slowDown>=0)?{message:"the `slowDown` setting should be a number >= 0."}:"barnesHutOptimize"in t&&typeof t.barnesHutOptimize!="boolean"?{message:"the `barnesHutOptimize` setting should be a boolean."}:"barnesHutTheta"in t&&!(typeof t.barnesHutTheta=="number"&&t.barnesHutTheta>=0)?{message:"the `barnesHutTheta` setting should be a number >= 0."}:null},ne.graphToByteArrays=function(t,r){var i=t.order,n=t.size,s={},u,d=new Float32Array(i*o),a=new Float32Array(n*e);return u=0,t.forEachNode(function(c,f){s[c]=u,d[u]=f.x,d[u+1]=f.y,d[u+2]=0,d[u+3]=0,d[u+4]=0,d[u+5]=0,d[u+6]=1,d[u+7]=1,d[u+8]=f.size||1,d[u+9]=f.fixed?1:0,u+=o}),u=0,t.forEachEdge(function(c,f,g,b,$,U,C){var I=s[g],N=s[b],z=r(c,f,g,b,$,U,C);d[I+6]+=z,d[N+6]+=z,a[u]=I,a[u+1]=N,a[u+2]=z,u+=e}),{nodes:d,edges:a}},ne.assignLayoutChanges=function(t,r,i){var n=0;t.updateEachNodeAttributes(function(s,u){return u.x=r[n],u.y=r[n+1],n+=o,i?i(s,u):u})},ne.readGraphPositions=function(t,r){var i=0;t.forEachNode(function(n,s){r[i]=s.x,r[i+1]=s.y,i+=o})},ne.collectLayoutChanges=function(t,r,i){for(var n=t.nodes(),s={},u=0,d=0,a=r.length;u<a;u+=o){if(i){var c=Object.assign({},t.getNodeAttributes(n[d]));c.x=r[u],c.y=r[u+1],c=i(n[d],c),s[n[d]]={x:c.x,y:c.y}}else s[n[d]]={x:r[u],y:r[u+1]};d++}return s},ne.createWorker=function(r){var i=window.URL||window.webkitURL,n=r.toString(),s=i.createObjectURL(new Blob(["("+n+").call(this);"],{type:"text/javascript"})),u=new Worker(s);return i.revokeObjectURL(s),u},ne}var gt,gr;function on(){return gr||(gr=1,gt={linLogMode:!1,outboundAttractionDistribution:!1,adjustSizes:!1,edgeWeightInfluence:1,scalingRatio:1,strongGravityMode:!1,gravity:1,slowDown:1,barnesHutOptimize:!1,barnesHutTheta:.5}),gt}var yt,yr;function sn(){if(yr)return yt;yr=1;var o=ee(),e=tn().createEdgeWeightGetter,t=rn(),r=nn(),i=on();function n(d,a,c){if(!o(a))throw new Error("graphology-layout-forceatlas2: the given graph is not a valid graphology instance.");typeof c=="number"&&(c={iterations:c});var f=c.iterations;if(typeof f!="number")throw new Error("graphology-layout-forceatlas2: invalid number of iterations.");if(f<=0)throw new Error("graphology-layout-forceatlas2: you should provide a positive number of iterations.");var g=e("getEdgeWeight"in c?c.getEdgeWeight:"weight").fromEntry,b=typeof c.outputReducer=="function"?c.outputReducer:null,$=r.assign({},i,c.settings),U=r.validateSettings($);if(U)throw new Error("graphology-layout-forceatlas2: "+U.message);var C=r.graphToByteArrays(a,g),I;for(I=0;I<f;I++)t($,C.nodes,C.edges);if(d){r.assignLayoutChanges(a,C.nodes,b);return}return r.collectLayoutChanges(a,C.nodes)}function s(d){var a=typeof d=="number"?d:d.order;return{barnesHutOptimize:a>2e3,strongGravityMode:!0,gravity:.05,scalingRatio:10,slowDown:1+Math.log(a)}}var u=n.bind(null,!1);return u.assign=n.bind(null,!0),u.inferSettings=s,yt=u,yt}var un=sn(),an=Se(un);const dn={directed:Yi,undirected:Vi,mixed:se};self.onmessage=function(o){const{type:e,graph:t,payload:r}=o.data,i=en.empty(dn[t.options.type],0);i.import(t);let n;try{switch(e){case"force":n=an(i,r);break;default:throw new Error(`Unknown algorithm type: ${e}`)}self.postMessage({type:e,result:n})}catch(s){self.postMessage({type:e,error:s.message})}}})();
