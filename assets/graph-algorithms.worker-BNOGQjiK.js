(function(){"use strict";function Ge(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}var $e={exports:{}},st;function Ht(){if(st)return $e.exports;st=1;var o=typeof Reflect=="object"?Reflect:null,e=o&&typeof o.apply=="function"?o.apply:function(g,E,A){return Function.prototype.apply.call(g,E,A)},t;o&&typeof o.ownKeys=="function"?t=o.ownKeys:Object.getOwnPropertySymbols?t=function(g){return Object.getOwnPropertyNames(g).concat(Object.getOwnPropertySymbols(g))}:t=function(g){return Object.getOwnPropertyNames(g)};function r(w){console&&console.warn&&console.warn(w)}var i=Number.isNaN||function(g){return g!==g};function n(){n.init.call(this)}$e.exports=n,$e.exports.once=N,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._eventsCount=0,n.prototype._maxListeners=void 0;var s=10;function u(w){if(typeof w!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof w)}Object.defineProperty(n,"defaultMaxListeners",{enumerable:!0,get:function(){return s},set:function(w){if(typeof w!="number"||w<0||i(w))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+w+".");s=w}}),n.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},n.prototype.setMaxListeners=function(g){if(typeof g!="number"||g<0||i(g))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+g+".");return this._maxListeners=g,this};function d(w){return w._maxListeners===void 0?n.defaultMaxListeners:w._maxListeners}n.prototype.getMaxListeners=function(){return d(this)},n.prototype.emit=function(g){for(var E=[],A=1;A<arguments.length;A++)E.push(arguments[A]);var k=g==="error",L=this._events;if(L!==void 0)k=k&&L.error===void 0;else if(!k)return!1;if(k){var I;if(E.length>0&&(I=E[0]),I instanceof Error)throw I;var J=new Error("Unhandled error."+(I?" ("+I.message+")":""));throw J.context=I,J}var F=L[g];if(F===void 0)return!1;if(typeof F=="function")e(F,this,E);else for(var c=F.length,pe=U(F,c),A=0;A<c;++A)e(pe[A],this,E);return!0};function a(w,g,E,A){var k,L,I;if(u(E),L=w._events,L===void 0?(L=w._events=Object.create(null),w._eventsCount=0):(L.newListener!==void 0&&(w.emit("newListener",g,E.listener?E.listener:E),L=w._events),I=L[g]),I===void 0)I=L[g]=E,++w._eventsCount;else if(typeof I=="function"?I=L[g]=A?[E,I]:[I,E]:A?I.unshift(E):I.push(E),k=d(w),k>0&&I.length>k&&!I.warned){I.warned=!0;var J=new Error("Possible EventEmitter memory leak detected. "+I.length+" "+String(g)+" listeners added. Use emitter.setMaxListeners() to increase limit");J.name="MaxListenersExceededWarning",J.emitter=w,J.type=g,J.count=I.length,r(J)}return w}n.prototype.addListener=function(g,E){return a(this,g,E,!1)},n.prototype.on=n.prototype.addListener,n.prototype.prependListener=function(g,E){return a(this,g,E,!0)};function h(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function l(w,g,E){var A={fired:!1,wrapFn:void 0,target:w,type:g,listener:E},k=h.bind(A);return k.listener=E,A.wrapFn=k,k}n.prototype.once=function(g,E){return u(E),this.on(g,l(this,g,E)),this},n.prototype.prependOnceListener=function(g,E){return u(E),this.prependListener(g,l(this,g,E)),this},n.prototype.removeListener=function(g,E){var A,k,L,I,J;if(u(E),k=this._events,k===void 0)return this;if(A=k[g],A===void 0)return this;if(A===E||A.listener===E)--this._eventsCount===0?this._events=Object.create(null):(delete k[g],k.removeListener&&this.emit("removeListener",g,A.listener||E));else if(typeof A!="function"){for(L=-1,I=A.length-1;I>=0;I--)if(A[I]===E||A[I].listener===E){J=A[I].listener,L=I;break}if(L<0)return this;L===0?A.shift():O(A,L),A.length===1&&(k[g]=A[0]),k.removeListener!==void 0&&this.emit("removeListener",g,J||E)}return this},n.prototype.off=n.prototype.removeListener,n.prototype.removeAllListeners=function(g){var E,A,k;if(A=this._events,A===void 0)return this;if(A.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):A[g]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete A[g]),this;if(arguments.length===0){var L=Object.keys(A),I;for(k=0;k<L.length;++k)I=L[k],I!=="removeListener"&&this.removeAllListeners(I);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(E=A[g],typeof E=="function")this.removeListener(g,E);else if(E!==void 0)for(k=E.length-1;k>=0;k--)this.removeListener(g,E[k]);return this};function y(w,g,E){var A=w._events;if(A===void 0)return[];var k=A[g];return k===void 0?[]:typeof k=="function"?E?[k.listener||k]:[k]:E?C(k):U(k,k.length)}n.prototype.listeners=function(g){return y(this,g,!0)},n.prototype.rawListeners=function(g){return y(this,g,!1)},n.listenerCount=function(w,g){return typeof w.listenerCount=="function"?w.listenerCount(g):v.call(w,g)},n.prototype.listenerCount=v;function v(w){var g=this._events;if(g!==void 0){var E=g[w];if(typeof E=="function")return 1;if(E!==void 0)return E.length}return 0}n.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]};function U(w,g){for(var E=new Array(g),A=0;A<g;++A)E[A]=w[A];return E}function O(w,g){for(;g+1<w.length;g++)w[g]=w[g+1];w.pop()}function C(w){for(var g=new Array(w.length),E=0;E<g.length;++E)g[E]=w[E].listener||w[E];return g}function N(w,g){return new Promise(function(E,A){function k(I){w.removeListener(g,L),A(I)}function L(){typeof w.removeListener=="function"&&w.removeListener("error",k),E([].slice.call(arguments))}W(w,g,L,{once:!0}),g!=="error"&&R(w,k,{once:!0})})}function R(w,g,E){typeof w.on=="function"&&W(w,"error",g,E)}function W(w,g,E,A){if(typeof w.on=="function")A.once?w.once(g,E):w.on(g,E);else if(typeof w.addEventListener=="function")w.addEventListener(g,function k(L){A.once&&w.removeEventListener(g,k),E(L)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof w)}return $e.exports}var xt=Ht(),je,ut;function ze(){if(ut)return je;ut=1;function o(e){if(typeof e!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=e}return typeof Symbol<"u"&&(o.prototype[Symbol.iterator]=function(){return this}),o.of=function(){var e=arguments,t=e.length,r=0;return new o(function(){return r>=t?{done:!0}:{done:!1,value:e[r++]}})},o.empty=function(){var e=new o(function(){return{done:!0}});return e},o.fromSequence=function(e){var t=0,r=e.length;return new o(function(){return t>=r?{done:!0}:{done:!1,value:e[t++]}})},o.is=function(e){return e instanceof o?!0:typeof e=="object"&&e!==null&&typeof e.next=="function"},je=o,je}var Yt=ze(),Y=Ge(Yt),De={},at;function Vt(){return at||(at=1,De.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u",De.SYMBOL_SUPPORT=typeof Symbol<"u"),De}var Te,dt;function ct(){if(dt)return Te;dt=1;var o=ze(),e=Vt(),t=e.ARRAY_BUFFER_SUPPORT,r=e.SYMBOL_SUPPORT;function i(n){return typeof n=="string"||Array.isArray(n)||t&&ArrayBuffer.isView(n)?o.fromSequence(n):typeof n!="object"||n===null?null:r&&typeof n[Symbol.iterator]=="function"?n[Symbol.iterator]():typeof n.next=="function"?n:null}return Te=function(s){var u=i(s);if(!u)throw new Error("obliterator: target is not iterable nor a valid iterator.");return u},Te}var We,ht;function Zt(){if(ht)return We;ht=1;var o=ct();return We=function(t,r){for(var i=arguments.length>1?r:1/0,n=i!==1/0?new Array(i):[],s,u=0,d=o(t);;){if(u===i)return n;if(s=d.next(),s.done)return u!==r&&(n.length=u),n;n[u++]=s.value}},We}var Jt=Zt(),ft=Ge(Jt),Pe,lt;function Qt(){if(lt)return Pe;lt=1;var o=ze(),e=ct();return Pe=function(){var r=arguments,i=null,n=-1;return new o(function(){var u=null;do{if(i===null){if(n++,n>=r.length)return{done:!0};i=e(r[n])}if(u=i.next(),u.done===!0){i=null;continue}break}while(!0);return u})},Pe}var Xt=Qt(),ee=Ge(Xt);function Mt(){const o=arguments[0];for(let e=1,t=arguments.length;e<t;e++)if(arguments[e])for(const r in arguments[e])o[r]=arguments[e][r];return o}let B=Mt;typeof Object.assign=="function"&&(B=Object.assign);function V(o,e,t,r){const i=o._nodes.get(e);let n=null;return i&&(r==="mixed"?n=i.out&&i.out[t]||i.undirected&&i.undirected[t]:r==="directed"?n=i.out&&i.out[t]:n=i.undirected&&i.undirected[t]),n}function H(o){return typeof o=="object"&&o!==null}function pt(o){let e;for(e in o)return!1;return!0}function Z(o,e,t){Object.defineProperty(o,e,{enumerable:!1,configurable:!1,writable:!0,value:t})}function X(o,e,t){const r={enumerable:!0,configurable:!0};typeof t=="function"?r.get=t:(r.value=t,r.writable=!1),Object.defineProperty(o,e,r)}function gt(o){return!(!H(o)||o.attributes&&!Array.isArray(o.attributes))}function er(){let o=Math.floor(Math.random()*256)&255;return()=>o++}class Ke extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}let _=class Bt extends Ke{constructor(e){super(e),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Bt.prototype.constructor)}};class b extends Ke{constructor(e){super(e),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,b.prototype.constructor)}}class G extends Ke{constructor(e){super(e),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G.prototype.constructor)}}function yt(o,e){this.key=o,this.attributes=e,this.clear()}yt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}};function wt(o,e){this.key=o,this.attributes=e,this.clear()}wt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}};function bt(o,e){this.key=o,this.attributes=e,this.clear()}bt.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}};function de(o,e,t,r,i){this.key=e,this.attributes=i,this.undirected=o,this.source=t,this.target=r}de.prototype.attach=function(){let o="out",e="in";this.undirected&&(o=e="undirected");const t=this.source.key,r=this.target.key;this.source[o][r]=this,!(this.undirected&&t===r)&&(this.target[e][t]=this)},de.prototype.attachMulti=function(){let o="out",e="in";const t=this.source.key,r=this.target.key;this.undirected&&(o=e="undirected");const i=this.source[o],n=i[r];if(typeof n>"u"){i[r]=this,this.undirected&&t===r||(this.target[e][t]=this);return}n.previous=this,this.next=n,i[r]=this,this.target[e][t]=this},de.prototype.detach=function(){const o=this.source.key,e=this.target.key;let t="out",r="in";this.undirected&&(t=r="undirected"),delete this.source[t][e],delete this.target[r][o]},de.prototype.detachMulti=function(){const o=this.source.key,e=this.target.key;let t="out",r="in";this.undirected&&(t=r="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[t][e],delete this.target[r][o]):(this.next.previous=void 0,this.source[t][e]=this.next,this.target[r][o]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const mt=0,vt=1,tr=2,Et=3;function te(o,e,t,r,i,n,s){let u,d,a,h;if(r=""+r,t===mt){if(u=o._nodes.get(r),!u)throw new b(`Graph.${e}: could not find the "${r}" node in the graph.`);a=i,h=n}else if(t===Et){if(i=""+i,d=o._edges.get(i),!d)throw new b(`Graph.${e}: could not find the "${i}" edge in the graph.`);const l=d.source.key,y=d.target.key;if(r===l)u=d.target;else if(r===y)u=d.source;else throw new b(`Graph.${e}: the "${r}" node is not attached to the "${i}" edge (${l}, ${y}).`);a=n,h=s}else{if(d=o._edges.get(r),!d)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`);t===vt?u=d.source:u=d.target,a=i,h=n}return[u,a,h]}function rr(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=te(this,e,t,r,i,n);return s.attributes[u]}}function ir(o,e,t){o.prototype[e]=function(r,i){const[n]=te(this,e,t,r,i);return n.attributes}}function nr(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=te(this,e,t,r,i,n);return s.attributes.hasOwnProperty(u)}}function or(o,e,t){o.prototype[e]=function(r,i,n,s){const[u,d,a]=te(this,e,t,r,i,n,s);return u.attributes[d]=a,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:d}),this}}function sr(o,e,t){o.prototype[e]=function(r,i,n,s){const[u,d,a]=te(this,e,t,r,i,n,s);if(typeof a!="function")throw new _(`Graph.${e}: updater should be a function.`);const h=u.attributes,l=a(h[d]);return h[d]=l,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:d}),this}}function ur(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=te(this,e,t,r,i,n);return delete s.attributes[u],this.emit("nodeAttributesUpdated",{key:s.key,type:"remove",attributes:s.attributes,name:u}),this}}function ar(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=te(this,e,t,r,i,n);if(!H(u))throw new _(`Graph.${e}: provided attributes are not a plain object.`);return s.attributes=u,this.emit("nodeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}function dr(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=te(this,e,t,r,i,n);if(!H(u))throw new _(`Graph.${e}: provided attributes are not a plain object.`);return B(s.attributes,u),this.emit("nodeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:u}),this}}function cr(o,e,t){o.prototype[e]=function(r,i,n){const[s,u]=te(this,e,t,r,i,n);if(typeof u!="function")throw new _(`Graph.${e}: provided updater is not a function.`);return s.attributes=u(s.attributes),this.emit("nodeAttributesUpdated",{key:s.key,type:"update",attributes:s.attributes}),this}}const hr=[{name:o=>`get${o}Attribute`,attacher:rr},{name:o=>`get${o}Attributes`,attacher:ir},{name:o=>`has${o}Attribute`,attacher:nr},{name:o=>`set${o}Attribute`,attacher:or},{name:o=>`update${o}Attribute`,attacher:sr},{name:o=>`remove${o}Attribute`,attacher:ur},{name:o=>`replace${o}Attributes`,attacher:ar},{name:o=>`merge${o}Attributes`,attacher:dr},{name:o=>`update${o}Attributes`,attacher:cr}];function fr(o){hr.forEach(function({name:e,attacher:t}){t(o,e("Node"),mt),t(o,e("Source"),vt),t(o,e("Target"),tr),t(o,e("Opposite"),Et)})}function lr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new b(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return n.attributes[i]}}function pr(o,e,t){o.prototype[e]=function(r){let i;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const n=""+r,s=""+arguments[1];if(i=V(this,n,s,t),!i)throw new b(`Graph.${e}: could not find an edge for the given path ("${n}" - "${s}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,i=this._edges.get(r),!i)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return i.attributes}}function gr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new b(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return n.attributes.hasOwnProperty(i)}}function yr(o,e,t){o.prototype[e]=function(r,i,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const u=""+r,d=""+i;if(i=arguments[2],n=arguments[3],s=V(this,u,d,t),!s)throw new b(`Graph.${e}: could not find an edge for the given path ("${u}" - "${d}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return s.attributes[i]=n,this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:i}),this}}function wr(o,e,t){o.prototype[e]=function(r,i,n){let s;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const u=""+r,d=""+i;if(i=arguments[2],n=arguments[3],s=V(this,u,d,t),!s)throw new b(`Graph.${e}: could not find an edge for the given path ("${u}" - "${d}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,s=this._edges.get(r),!s)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(typeof n!="function")throw new _(`Graph.${e}: updater should be a function.`);return s.attributes[i]=n(s.attributes[i]),this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:i}),this}}function br(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new b(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`)}return delete n.attributes[i],this.emit("edgeAttributesUpdated",{key:n.key,type:"remove",attributes:n.attributes,name:i}),this}}function mr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new b(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(!H(i))throw new _(`Graph.${e}: provided attributes are not a plain object.`);return n.attributes=i,this.emit("edgeAttributesUpdated",{key:n.key,type:"replace",attributes:n.attributes}),this}}function vr(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new b(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(!H(i))throw new _(`Graph.${e}: provided attributes are not a plain object.`);return B(n.attributes,i),this.emit("edgeAttributesUpdated",{key:n.key,type:"merge",attributes:n.attributes,data:i}),this}}function Er(o,e,t){o.prototype[e]=function(r,i){let n;if(this.type!=="mixed"&&t!=="mixed"&&t!==this.type)throw new G(`Graph.${e}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${e}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+r,u=""+i;if(i=arguments[2],n=V(this,s,u,t),!n)throw new b(`Graph.${e}: could not find an edge for the given path ("${s}" - "${u}").`)}else{if(t!=="mixed")throw new G(`Graph.${e}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(r=""+r,n=this._edges.get(r),!n)throw new b(`Graph.${e}: could not find the "${r}" edge in the graph.`)}if(typeof i!="function")throw new _(`Graph.${e}: provided updater is not a function.`);return n.attributes=i(n.attributes),this.emit("edgeAttributesUpdated",{key:n.key,type:"update",attributes:n.attributes}),this}}const _r=[{name:o=>`get${o}Attribute`,attacher:lr},{name:o=>`get${o}Attributes`,attacher:pr},{name:o=>`has${o}Attribute`,attacher:gr},{name:o=>`set${o}Attribute`,attacher:yr},{name:o=>`update${o}Attribute`,attacher:wr},{name:o=>`remove${o}Attribute`,attacher:br},{name:o=>`replace${o}Attributes`,attacher:mr},{name:o=>`merge${o}Attributes`,attacher:vr},{name:o=>`update${o}Attributes`,attacher:Er}];function Ar(o){_r.forEach(function({name:e,attacher:t}){t(o,e("Edge"),"mixed"),t(o,e("DirectedEdge"),"directed"),t(o,e("UndirectedEdge"),"undirected")})}const Gr=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function $r(o,e,t,r){let i=!1;for(const n in e){if(n===r)continue;const s=e[n];if(i=t(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),o&&i)return s.key}}function Dr(o,e,t,r){let i,n,s,u=!1;for(const d in e)if(d!==r){i=e[d];do{if(n=i.source,s=i.target,u=t(i.key,i.attributes,n.key,s.key,n.attributes,s.attributes,i.undirected),o&&u)return i.key;i=i.next}while(i!==void 0)}}function qe(o,e){const t=Object.keys(o),r=t.length;let i,n=0;return new Y(function(){do if(i)i=i.next;else{if(n>=r)return{done:!0};const u=t[n++];if(u===e){i=void 0;continue}i=o[u]}while(!i);return{done:!1,value:{edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected}}})}function Sr(o,e,t,r){const i=e[t];if(!i)return;const n=i.source,s=i.target;if(r(i.key,i.attributes,n.key,s.key,n.attributes,s.attributes,i.undirected)&&o)return i.key}function kr(o,e,t,r){let i=e[t];if(!i)return;let n=!1;do{if(n=r(i.key,i.attributes,i.source.key,i.target.key,i.source.attributes,i.target.attributes,i.undirected),o&&n)return i.key;i=i.next}while(i!==void 0)}function Be(o,e){let t=o[e];return t.next!==void 0?new Y(function(){if(!t)return{done:!0};const r={edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected};return t=t.next,{done:!1,value:r}}):Y.of({edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected})}function Lr(o,e){if(o.size===0)return[];if(e==="mixed"||e===o.type)return typeof Array.from=="function"?Array.from(o._edges.keys()):ft(o._edges.keys(),o._edges.size);const t=e==="undirected"?o.undirectedSize:o.directedSize,r=new Array(t),i=e==="undirected",n=o._edges.values();let s=0,u,d;for(;u=n.next(),u.done!==!0;)d=u.value,d.undirected===i&&(r[s++]=d.key);return r}function _t(o,e,t,r){if(e.size===0)return;const i=t!=="mixed"&&t!==e.type,n=t==="undirected";let s,u,d=!1;const a=e._edges.values();for(;s=a.next(),s.done!==!0;){if(u=s.value,i&&u.undirected!==n)continue;const{key:h,attributes:l,source:y,target:v}=u;if(d=r(h,l,y.key,v.key,y.attributes,v.attributes,u.undirected),o&&d)return h}}function Ur(o,e){if(o.size===0)return Y.empty();const t=e!=="mixed"&&e!==o.type,r=e==="undirected",i=o._edges.values();return new Y(function(){let s,u;for(;;){if(s=i.next(),s.done)return s;if(u=s.value,!(t&&u.undirected!==r))break}return{value:{edge:u.key,attributes:u.attributes,source:u.source.key,target:u.target.key,sourceAttributes:u.source.attributes,targetAttributes:u.target.attributes,undirected:u.undirected},done:!1}})}function He(o,e,t,r,i,n){const s=e?Dr:$r;let u;if(t!=="undirected"&&(r!=="out"&&(u=s(o,i.in,n),o&&u)||r!=="in"&&(u=s(o,i.out,n,r?void 0:i.key),o&&u))||t!=="directed"&&(u=s(o,i.undirected,n),o&&u))return u}function Or(o,e,t,r){const i=[];return He(!1,o,e,t,r,function(n){i.push(n)}),i}function Ir(o,e,t){let r=Y.empty();return o!=="undirected"&&(e!=="out"&&typeof t.in<"u"&&(r=ee(r,qe(t.in))),e!=="in"&&typeof t.out<"u"&&(r=ee(r,qe(t.out,e?void 0:t.key)))),o!=="directed"&&typeof t.undirected<"u"&&(r=ee(r,qe(t.undirected))),r}function xe(o,e,t,r,i,n,s){const u=t?kr:Sr;let d;if(e!=="undirected"&&(typeof i.in<"u"&&r!=="out"&&(d=u(o,i.in,n,s),o&&d)||typeof i.out<"u"&&r!=="in"&&(r||i.key!==n)&&(d=u(o,i.out,n,s),o&&d))||e!=="directed"&&typeof i.undirected<"u"&&(d=u(o,i.undirected,n,s),o&&d))return d}function Rr(o,e,t,r,i){const n=[];return xe(!1,o,e,t,r,i,function(s){n.push(s)}),n}function Cr(o,e,t,r){let i=Y.empty();return o!=="undirected"&&(typeof t.in<"u"&&e!=="out"&&r in t.in&&(i=ee(i,Be(t.in,r))),typeof t.out<"u"&&e!=="in"&&r in t.out&&(e||t.key!==r)&&(i=ee(i,Be(t.out,r)))),o!=="directed"&&typeof t.undirected<"u"&&r in t.undirected&&(i=ee(i,Be(t.undirected,r))),i}function Nr(o,e){const{name:t,type:r,direction:i}=e;o.prototype[t]=function(n,s){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return[];if(!arguments.length)return Lr(this,r);if(arguments.length===1){n=""+n;const u=this._nodes.get(n);if(typeof u>"u")throw new b(`Graph.${t}: could not find the "${n}" node in the graph.`);return Or(this.multi,r==="mixed"?this.type:r,i,u)}if(arguments.length===2){n=""+n,s=""+s;const u=this._nodes.get(n);if(!u)throw new b(`Graph.${t}:  could not find the "${n}" source node in the graph.`);if(!this._nodes.has(s))throw new b(`Graph.${t}:  could not find the "${s}" target node in the graph.`);return Rr(r,this.multi,i,u,s)}throw new _(`Graph.${t}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Fr(o,e){const{name:t,type:r,direction:i}=e,n="forEach"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[n]=function(a,h,l){if(!(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)){if(arguments.length===1)return l=a,_t(!1,this,r,l);if(arguments.length===2){a=""+a,l=h;const y=this._nodes.get(a);if(typeof y>"u")throw new b(`Graph.${n}: could not find the "${a}" node in the graph.`);return He(!1,this.multi,r==="mixed"?this.type:r,i,y,l)}if(arguments.length===3){a=""+a,h=""+h;const y=this._nodes.get(a);if(!y)throw new b(`Graph.${n}:  could not find the "${a}" source node in the graph.`);if(!this._nodes.has(h))throw new b(`Graph.${n}:  could not find the "${h}" target node in the graph.`);return xe(!1,r,this.multi,i,y,h,l)}throw new _(`Graph.${n}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const s="map"+t[0].toUpperCase()+t.slice(1);o.prototype[s]=function(){const a=Array.prototype.slice.call(arguments),h=a.pop();let l;if(a.length===0){let y=0;r!=="directed"&&(y+=this.undirectedSize),r!=="undirected"&&(y+=this.directedSize),l=new Array(y);let v=0;a.push((U,O,C,N,R,W,w)=>{l[v++]=h(U,O,C,N,R,W,w)})}else l=[],a.push((y,v,U,O,C,N,R)=>{l.push(h(y,v,U,O,C,N,R))});return this[n].apply(this,a),l};const u="filter"+t[0].toUpperCase()+t.slice(1);o.prototype[u]=function(){const a=Array.prototype.slice.call(arguments),h=a.pop(),l=[];return a.push((y,v,U,O,C,N,R)=>{h(y,v,U,O,C,N,R)&&l.push(y)}),this[n].apply(this,a),l};const d="reduce"+t[0].toUpperCase()+t.slice(1);o.prototype[d]=function(){let a=Array.prototype.slice.call(arguments);if(a.length<2||a.length>4)throw new _(`Graph.${d}: invalid number of arguments (expecting 2, 3 or 4 and got ${a.length}).`);if(typeof a[a.length-1]=="function"&&typeof a[a.length-2]!="function")throw new _(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let h,l;a.length===2?(h=a[0],l=a[1],a=[]):a.length===3?(h=a[1],l=a[2],a=[a[0]]):a.length===4&&(h=a[2],l=a[3],a=[a[0],a[1]]);let y=l;return a.push((v,U,O,C,N,R,W)=>{y=h(y,v,U,O,C,N,R,W)}),this[n].apply(this,a),y}}function jr(o,e){const{name:t,type:r,direction:i}=e,n="find"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[n]=function(d,a,h){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return!1;if(arguments.length===1)return h=d,_t(!0,this,r,h);if(arguments.length===2){d=""+d,h=a;const l=this._nodes.get(d);if(typeof l>"u")throw new b(`Graph.${n}: could not find the "${d}" node in the graph.`);return He(!0,this.multi,r==="mixed"?this.type:r,i,l,h)}if(arguments.length===3){d=""+d,a=""+a;const l=this._nodes.get(d);if(!l)throw new b(`Graph.${n}:  could not find the "${d}" source node in the graph.`);if(!this._nodes.has(a))throw new b(`Graph.${n}:  could not find the "${a}" target node in the graph.`);return xe(!0,r,this.multi,i,l,a,h)}throw new _(`Graph.${n}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const s="some"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[s]=function(){const d=Array.prototype.slice.call(arguments),a=d.pop();return d.push((l,y,v,U,O,C,N)=>a(l,y,v,U,O,C,N)),!!this[n].apply(this,d)};const u="every"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[u]=function(){const d=Array.prototype.slice.call(arguments),a=d.pop();return d.push((l,y,v,U,O,C,N)=>!a(l,y,v,U,O,C,N)),!this[n].apply(this,d)}}function zr(o,e){const{name:t,type:r,direction:i}=e,n=t.slice(0,-1)+"Entries";o.prototype[n]=function(s,u){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return Y.empty();if(!arguments.length)return Ur(this,r);if(arguments.length===1){s=""+s;const d=this._nodes.get(s);if(!d)throw new b(`Graph.${n}: could not find the "${s}" node in the graph.`);return Ir(r,i,d)}if(arguments.length===2){s=""+s,u=""+u;const d=this._nodes.get(s);if(!d)throw new b(`Graph.${n}:  could not find the "${s}" source node in the graph.`);if(!this._nodes.has(u))throw new b(`Graph.${n}:  could not find the "${u}" target node in the graph.`);return Cr(r,i,d,u)}throw new _(`Graph.${n}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Tr(o){Gr.forEach(e=>{Nr(o,e),Fr(o,e),jr(o,e),zr(o,e)})}const Wr=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function Se(){this.A=null,this.B=null}Se.prototype.wrap=function(o){this.A===null?this.A=o:this.B===null&&(this.B=o)},Se.prototype.has=function(o){return this.A!==null&&o in this.A||this.B!==null&&o in this.B};function me(o,e,t,r,i){for(const n in r){const s=r[n],u=s.source,d=s.target,a=u===t?d:u;if(e&&e.has(a.key))continue;const h=i(a.key,a.attributes);if(o&&h)return a.key}}function Ye(o,e,t,r,i){if(e!=="mixed"){if(e==="undirected")return me(o,null,r,r.undirected,i);if(typeof t=="string")return me(o,null,r,r[t],i)}const n=new Se;let s;if(e!=="undirected"){if(t!=="out"){if(s=me(o,null,r,r.in,i),o&&s)return s;n.wrap(r.in)}if(t!=="in"){if(s=me(o,n,r,r.out,i),o&&s)return s;n.wrap(r.out)}}if(e!=="directed"&&(s=me(o,n,r,r.undirected,i),o&&s))return s}function Pr(o,e,t){if(o!=="mixed"){if(o==="undirected")return Object.keys(t.undirected);if(typeof e=="string")return Object.keys(t[e])}const r=[];return Ye(!1,o,e,t,function(i){r.push(i)}),r}function ve(o,e,t){const r=Object.keys(t),i=r.length;let n=0;return new Y(function(){let u=null;do{if(n>=i)return o&&o.wrap(t),{done:!0};const d=t[r[n++]],a=d.source,h=d.target;if(u=a===e?h:a,o&&o.has(u.key)){u=null;continue}}while(u===null);return{done:!1,value:{neighbor:u.key,attributes:u.attributes}}})}function Kr(o,e,t){if(o!=="mixed"){if(o==="undirected")return ve(null,t,t.undirected);if(typeof e=="string")return ve(null,t,t[e])}let r=Y.empty();const i=new Se;return o!=="undirected"&&(e!=="out"&&(r=ee(r,ve(i,t,t.in))),e!=="in"&&(r=ee(r,ve(i,t,t.out)))),o!=="directed"&&(r=ee(r,ve(i,t,t.undirected))),r}function qr(o,e){const{name:t,type:r,direction:i}=e;o.prototype[t]=function(n){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return[];n=""+n;const s=this._nodes.get(n);if(typeof s>"u")throw new b(`Graph.${t}: could not find the "${n}" node in the graph.`);return Pr(r==="mixed"?this.type:r,i,s)}}function Br(o,e){const{name:t,type:r,direction:i}=e,n="forEach"+t[0].toUpperCase()+t.slice(1,-1);o.prototype[n]=function(a,h){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return;a=""+a;const l=this._nodes.get(a);if(typeof l>"u")throw new b(`Graph.${n}: could not find the "${a}" node in the graph.`);Ye(!1,r==="mixed"?this.type:r,i,l,h)};const s="map"+t[0].toUpperCase()+t.slice(1);o.prototype[s]=function(a,h){const l=[];return this[n](a,(y,v)=>{l.push(h(y,v))}),l};const u="filter"+t[0].toUpperCase()+t.slice(1);o.prototype[u]=function(a,h){const l=[];return this[n](a,(y,v)=>{h(y,v)&&l.push(y)}),l};const d="reduce"+t[0].toUpperCase()+t.slice(1);o.prototype[d]=function(a,h,l){if(arguments.length<3)throw new _(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let y=l;return this[n](a,(v,U)=>{y=h(y,v,U)}),y}}function Hr(o,e){const{name:t,type:r,direction:i}=e,n=t[0].toUpperCase()+t.slice(1,-1),s="find"+n;o.prototype[s]=function(a,h){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return;a=""+a;const l=this._nodes.get(a);if(typeof l>"u")throw new b(`Graph.${s}: could not find the "${a}" node in the graph.`);return Ye(!0,r==="mixed"?this.type:r,i,l,h)};const u="some"+n;o.prototype[u]=function(a,h){return!!this[s](a,h)};const d="every"+n;o.prototype[d]=function(a,h){return!this[s](a,(y,v)=>!h(y,v))}}function xr(o,e){const{name:t,type:r,direction:i}=e,n=t.slice(0,-1)+"Entries";o.prototype[n]=function(s){if(r!=="mixed"&&this.type!=="mixed"&&r!==this.type)return Y.empty();s=""+s;const u=this._nodes.get(s);if(typeof u>"u")throw new b(`Graph.${n}: could not find the "${s}" node in the graph.`);return Kr(r==="mixed"?this.type:r,i,u)}}function Yr(o){Wr.forEach(e=>{qr(o,e),Br(o,e),Hr(o,e),xr(o,e)})}function ke(o,e,t,r,i){const n=r._nodes.values(),s=r.type;let u,d,a,h,l,y;for(;u=n.next(),u.done!==!0;){let v=!1;if(d=u.value,s!=="undirected"){h=d.out;for(a in h){l=h[a];do y=l.target,v=!0,i(d.key,y.key,d.attributes,y.attributes,l.key,l.attributes,l.undirected),l=l.next;while(l)}}if(s!=="directed"){h=d.undirected;for(a in h)if(!(e&&d.key>a)){l=h[a];do y=l.target,y.key!==a&&(y=l.source),v=!0,i(d.key,y.key,d.attributes,y.attributes,l.key,l.attributes,l.undirected),l=l.next;while(l)}}t&&!v&&i(d.key,null,d.attributes,null,null,null,null)}}function Vr(o,e){const t={key:o};return pt(e.attributes)||(t.attributes=B({},e.attributes)),t}function Zr(o,e,t){const r={key:e,source:t.source.key,target:t.target.key};return pt(t.attributes)||(r.attributes=B({},t.attributes)),o==="mixed"&&t.undirected&&(r.undirected=!0),r}function Jr(o){if(!H(o))throw new _('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in o))throw new _("Graph.import: serialized node is missing its key.");if("attributes"in o&&(!H(o.attributes)||o.attributes===null))throw new _("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function Qr(o){if(!H(o))throw new _('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in o))throw new _("Graph.import: serialized edge is missing its source.");if(!("target"in o))throw new _("Graph.import: serialized edge is missing its target.");if("attributes"in o&&(!H(o.attributes)||o.attributes===null))throw new _("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in o&&typeof o.undirected!="boolean")throw new _("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const Xr=er(),Mr=new Set(["directed","undirected","mixed"]),At=new Set(["domain","_events","_eventsCount","_maxListeners"]),ei=[{name:o=>`${o}Edge`,generateKey:!0},{name:o=>`${o}DirectedEdge`,generateKey:!0,type:"directed"},{name:o=>`${o}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:o=>`${o}EdgeWithKey`},{name:o=>`${o}DirectedEdgeWithKey`,type:"directed"},{name:o=>`${o}UndirectedEdgeWithKey`,type:"undirected"}],ti={allowSelfLoops:!0,multi:!1,type:"mixed"};function ri(o,e,t){if(t&&!H(t))throw new _(`Graph.addNode: invalid attributes. Expecting an object but got "${t}"`);if(e=""+e,t=t||{},o._nodes.has(e))throw new G(`Graph.addNode: the "${e}" node already exist in the graph.`);const r=new o.NodeDataClass(e,t);return o._nodes.set(e,r),o.emit("nodeAdded",{key:e,attributes:t}),r}function Gt(o,e,t){const r=new o.NodeDataClass(e,t);return o._nodes.set(e,r),o.emit("nodeAdded",{key:e,attributes:t}),r}function $t(o,e,t,r,i,n,s,u){if(!r&&o.type==="undirected")throw new G(`Graph.${e}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(r&&o.type==="directed")throw new G(`Graph.${e}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(u&&!H(u))throw new _(`Graph.${e}: invalid attributes. Expecting an object but got "${u}"`);if(n=""+n,s=""+s,u=u||{},!o.allowSelfLoops&&n===s)throw new G(`Graph.${e}: source & target are the same ("${n}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const d=o._nodes.get(n),a=o._nodes.get(s);if(!d)throw new b(`Graph.${e}: source node "${n}" not found.`);if(!a)throw new b(`Graph.${e}: target node "${s}" not found.`);const h={key:null,undirected:r,source:n,target:s,attributes:u};if(t)i=o._edgeKeyGenerator();else if(i=""+i,o._edges.has(i))throw new G(`Graph.${e}: the "${i}" edge already exists in the graph.`);if(!o.multi&&(r?typeof d.undirected[s]<"u":typeof d.out[s]<"u"))throw new G(`Graph.${e}: an edge linking "${n}" to "${s}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const l=new de(r,i,d,a,u);o._edges.set(i,l);const y=n===s;return r?(d.undirectedDegree++,a.undirectedDegree++,y&&(d.undirectedLoops++,o._undirectedSelfLoopCount++)):(d.outDegree++,a.inDegree++,y&&(d.directedLoops++,o._directedSelfLoopCount++)),o.multi?l.attachMulti():l.attach(),r?o._undirectedSize++:o._directedSize++,h.key=i,o.emit("edgeAdded",h),i}function ii(o,e,t,r,i,n,s,u,d){if(!r&&o.type==="undirected")throw new G(`Graph.${e}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(r&&o.type==="directed")throw new G(`Graph.${e}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(u){if(d){if(typeof u!="function")throw new _(`Graph.${e}: invalid updater function. Expecting a function but got "${u}"`)}else if(!H(u))throw new _(`Graph.${e}: invalid attributes. Expecting an object but got "${u}"`)}n=""+n,s=""+s;let a;if(d&&(a=u,u=void 0),!o.allowSelfLoops&&n===s)throw new G(`Graph.${e}: source & target are the same ("${n}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let h=o._nodes.get(n),l=o._nodes.get(s),y,v;if(!t&&(y=o._edges.get(i),y)){if((y.source.key!==n||y.target.key!==s)&&(!r||y.source.key!==s||y.target.key!==n))throw new G(`Graph.${e}: inconsistency detected when attempting to merge the "${i}" edge with "${n}" source & "${s}" target vs. ("${y.source.key}", "${y.target.key}").`);v=y}if(!v&&!o.multi&&h&&(v=r?h.undirected[s]:h.out[s]),v){const R=[v.key,!1,!1,!1];if(d?!a:!u)return R;if(d){const W=v.attributes;v.attributes=a(W),o.emit("edgeAttributesUpdated",{type:"replace",key:v.key,attributes:v.attributes})}else B(v.attributes,u),o.emit("edgeAttributesUpdated",{type:"merge",key:v.key,attributes:v.attributes,data:u});return R}u=u||{},d&&a&&(u=a(u));const U={key:null,undirected:r,source:n,target:s,attributes:u};if(t)i=o._edgeKeyGenerator();else if(i=""+i,o._edges.has(i))throw new G(`Graph.${e}: the "${i}" edge already exists in the graph.`);let O=!1,C=!1;h||(h=Gt(o,n,{}),O=!0,n===s&&(l=h,C=!0)),l||(l=Gt(o,s,{}),C=!0),y=new de(r,i,h,l,u),o._edges.set(i,y);const N=n===s;return r?(h.undirectedDegree++,l.undirectedDegree++,N&&(h.undirectedLoops++,o._undirectedSelfLoopCount++)):(h.outDegree++,l.inDegree++,N&&(h.directedLoops++,o._directedSelfLoopCount++)),o.multi?y.attachMulti():y.attach(),r?o._undirectedSize++:o._directedSize++,U.key=i,o.emit("edgeAdded",U),[i,!0,O,C]}function ce(o,e){o._edges.delete(e.key);const{source:t,target:r,attributes:i}=e,n=e.undirected,s=t===r;n?(t.undirectedDegree--,r.undirectedDegree--,s&&(t.undirectedLoops--,o._undirectedSelfLoopCount--)):(t.outDegree--,r.inDegree--,s&&(t.directedLoops--,o._directedSelfLoopCount--)),o.multi?e.detachMulti():e.detach(),n?o._undirectedSize--:o._directedSize--,o.emit("edgeDropped",{key:e.key,attributes:i,source:t.key,target:r.key,undirected:n})}class T extends xt.EventEmitter{constructor(e){if(super(),e=B({},ti,e),typeof e.multi!="boolean")throw new _(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!Mr.has(e.type))throw new _(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if(typeof e.allowSelfLoops!="boolean")throw new _(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);const t=e.type==="mixed"?yt:e.type==="directed"?wt:bt;Z(this,"NodeDataClass",t);const r="geid_"+Xr()+"_";let i=0;const n=()=>{let s;do s=r+i++;while(this._edges.has(s));return s};Z(this,"_attributes",{}),Z(this,"_nodes",new Map),Z(this,"_edges",new Map),Z(this,"_directedSize",0),Z(this,"_undirectedSize",0),Z(this,"_directedSelfLoopCount",0),Z(this,"_undirectedSelfLoopCount",0),Z(this,"_edgeKeyGenerator",n),Z(this,"_options",e),At.forEach(s=>Z(this,s,this[s])),X(this,"order",()=>this._nodes.size),X(this,"size",()=>this._edges.size),X(this,"directedSize",()=>this._directedSize),X(this,"undirectedSize",()=>this._undirectedSize),X(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),X(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),X(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),X(this,"multi",this._options.multi),X(this,"type",this._options.type),X(this,"allowSelfLoops",this._options.allowSelfLoops),X(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if(this.type==="undirected")return!1;if(arguments.length===1){const r=""+e,i=this._edges.get(r);return!!i&&!i.undirected}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);return r?r.out.hasOwnProperty(t):!1}throw new _(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if(this.type==="directed")return!1;if(arguments.length===1){const r=""+e,i=this._edges.get(r);return!!i&&i.undirected}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);return r?r.undirected.hasOwnProperty(t):!1}throw new _(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(arguments.length===1){const r=""+e;return this._edges.has(r)}else if(arguments.length===2){e=""+e,t=""+t;const r=this._nodes.get(e);return r?typeof r.out<"u"&&r.out.hasOwnProperty(t)||typeof r.undirected<"u"&&r.undirected.hasOwnProperty(t):!1}throw new _(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if(this.type==="undirected")return;if(e=""+e,t=""+t,this.multi)throw new G("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const r=this._nodes.get(e);if(!r)throw new b(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);const i=r.out&&r.out[t]||void 0;if(i)return i.key}undirectedEdge(e,t){if(this.type==="directed")return;if(e=""+e,t=""+t,this.multi)throw new G("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const r=this._nodes.get(e);if(!r)throw new b(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);const i=r.undirected&&r.undirected[t]||void 0;if(i)return i.key}edge(e,t){if(this.multi)throw new G("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new b(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.edge: could not find the "${t}" target node in the graph.`);const i=r.out&&r.out[t]||r.undirected&&r.undirected[t]||void 0;if(i)return i.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new b(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.in||t in r.out}areOutNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new b(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.out}areInNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new b(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return this.type==="undirected"?!1:t in r.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new b(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return this.type==="directed"?!1:t in r.undirected}areNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new b(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&(t in r.in||t in r.out)||this.type!=="directed"&&t in r.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new b(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in r.in||this.type!=="directed"&&t in r.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;const r=this._nodes.get(e);if(!r)throw new b(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return this.type!=="undirected"&&t in r.out||this.type!=="directed"&&t in r.undirected}inDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.inDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree}outDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.outDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree}directedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree}inboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.inDegree),r}outboundDegree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.outDegree),r}degree(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.degree: could not find the "${e}" node in the graph.`);let r=0;return this.type!=="directed"&&(r+=t.undirectedDegree),this.type!=="undirected"&&(r+=t.inDegree+t.outDegree),r}inDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="undirected"?0:t.inDegree+t.outDegree-t.directedLoops*2}undirectedDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return this.type==="directed"?0:t.undirectedDegree-t.undirectedLoops*2}inboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return this.type!=="directed"&&(r+=t.undirectedDegree,i+=t.undirectedLoops*2),this.type!=="undirected"&&(r+=t.inDegree,i+=t.directedLoops),r-i}outboundDegreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return this.type!=="directed"&&(r+=t.undirectedDegree,i+=t.undirectedLoops*2),this.type!=="undirected"&&(r+=t.outDegree,i+=t.directedLoops),r-i}degreeWithoutSelfLoops(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return this.type!=="directed"&&(r+=t.undirectedDegree,i+=t.undirectedLoops*2),this.type!=="undirected"&&(r+=t.inDegree+t.outDegree,i+=t.directedLoops*2),r-i}source(e){e=""+e;const t=this._edges.get(e);if(!t)throw new b(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;const t=this._edges.get(e);if(!t)throw new b(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;const t=this._edges.get(e);if(!t)throw new b(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;const r=this._edges.get(t);if(!r)throw new b(`Graph.opposite: could not find the "${t}" edge in the graph.`);const i=r.source.key,n=r.target.key;if(e===i)return n;if(e===n)return i;throw new b(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${i}, ${n}).`)}hasExtremity(e,t){e=""+e,t=""+t;const r=this._edges.get(e);if(!r)throw new b(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return r.source.key===t||r.target.key===t}isUndirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new b(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;const t=this._edges.get(e);if(!t)throw new b(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;const t=this._edges.get(e);if(!t)throw new b(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return ri(this,e,t).key}mergeNode(e,t){if(t&&!H(t))throw new _(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let r=this._nodes.get(e);return r?(t&&(B(r.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:r.attributes,data:t})),[e,!1]):(r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&typeof t!="function")throw new _(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let r=this._nodes.get(e);if(r){if(t){const n=r.attributes;r.attributes=t(n),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:r.attributes})}return[e,!1]}const i=t?t({}):{};return r=new this.NodeDataClass(e,i),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:i}),[e,!0]}dropNode(e){e=""+e;const t=this._nodes.get(e);if(!t)throw new b(`Graph.dropNode: could not find the "${e}" node in the graph.`);let r;if(this.type!=="undirected"){for(const i in t.out){r=t.out[i];do ce(this,r),r=r.next;while(r)}for(const i in t.in){r=t.in[i];do ce(this,r),r=r.next;while(r)}}if(this.type!=="directed")for(const i in t.undirected){r=t.undirected[i];do ce(this,r),r=r.next;while(r)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(arguments.length>1){const r=""+arguments[0],i=""+arguments[1];if(t=V(this,r,i,this.type),!t)throw new b(`Graph.dropEdge: could not find the "${r}" -> "${i}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new b(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return ce(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new G("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new G("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");e=""+e,t=""+t;const r=V(this,e,t,"directed");if(!r)throw new b(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return ce(this,r),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new G("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new G("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const r=V(this,e,t,"undirected");if(!r)throw new b(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return ce(this,r),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),t.done!==!0;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if(typeof t!="function")throw new _("Graph.updateAttribute: updater should be a function.");const r=this._attributes[e];return this._attributes[e]=t(r),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!H(e))throw new _("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!H(e))throw new _("Graph.mergeAttributes: provided attributes are not a plain object.");return B(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if(typeof e!="function")throw new _("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if(typeof e!="function")throw new _("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!gt(t))throw new _("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._nodes.values();let i,n;for(;i=r.next(),i.done!==!0;)n=i.value,n.attributes=e(n.key,n.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if(typeof e!="function")throw new _("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!gt(t))throw new _("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._edges.values();let i,n,s,u;for(;i=r.next(),i.done!==!0;)n=i.value,s=n.source,u=n.target,n.attributes=e(n.key,n.attributes,s.key,u.key,s.attributes,u.attributes,n.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if(typeof e!="function")throw new _("Graph.forEachAdjacencyEntry: expecting a callback.");ke(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new _("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");ke(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if(typeof e!="function")throw new _("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");ke(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if(typeof e!="function")throw new _("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");ke(!1,!0,!0,this,e)}nodes(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):ft(this._nodes.keys(),this._nodes.size)}forEachNode(e){if(typeof e!="function")throw new _("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();let r,i;for(;r=t.next(),r.done!==!0;)i=r.value,e(i.key,i.attributes)}findNode(e){if(typeof e!="function")throw new _("Graph.findNode: expecting a callback.");const t=this._nodes.values();let r,i;for(;r=t.next(),r.done!==!0;)if(i=r.value,e(i.key,i.attributes))return i.key}mapNodes(e){if(typeof e!="function")throw new _("Graph.mapNode: expecting a callback.");const t=this._nodes.values();let r,i;const n=new Array(this.order);let s=0;for(;r=t.next(),r.done!==!0;)i=r.value,n[s++]=e(i.key,i.attributes);return n}someNode(e){if(typeof e!="function")throw new _("Graph.someNode: expecting a callback.");const t=this._nodes.values();let r,i;for(;r=t.next(),r.done!==!0;)if(i=r.value,e(i.key,i.attributes))return!0;return!1}everyNode(e){if(typeof e!="function")throw new _("Graph.everyNode: expecting a callback.");const t=this._nodes.values();let r,i;for(;r=t.next(),r.done!==!0;)if(i=r.value,!e(i.key,i.attributes))return!1;return!0}filterNodes(e){if(typeof e!="function")throw new _("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();let r,i;const n=[];for(;r=t.next(),r.done!==!0;)i=r.value,e(i.key,i.attributes)&&n.push(i.key);return n}reduceNodes(e,t){if(typeof e!="function")throw new _("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new _("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let r=t;const i=this._nodes.values();let n,s;for(;n=i.next(),n.done!==!0;)s=n.value,r=e(r,s.key,s.attributes);return r}nodeEntries(){const e=this._nodes.values();return new Y(()=>{const t=e.next();if(t.done)return t;const r=t.value;return{value:{node:r.key,attributes:r.attributes},done:!1}})}export(){const e=new Array(this._nodes.size);let t=0;this._nodes.forEach((i,n)=>{e[t++]=Vr(n,i)});const r=new Array(this._edges.size);return t=0,this._edges.forEach((i,n)=>{r[t++]=Zr(this.type,n,i)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:r}}import(e,t=!1){if(e instanceof T)return e.forEachNode((d,a)=>{t?this.mergeNode(d,a):this.addNode(d,a)}),e.forEachEdge((d,a,h,l,y,v,U)=>{t?U?this.mergeUndirectedEdgeWithKey(d,h,l,a):this.mergeDirectedEdgeWithKey(d,h,l,a):U?this.addUndirectedEdgeWithKey(d,h,l,a):this.addDirectedEdgeWithKey(d,h,l,a)}),this;if(!H(e))throw new _("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!H(e.attributes))throw new _("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let r,i,n,s,u;if(e.nodes){if(n=e.nodes,!Array.isArray(n))throw new _("Graph.import: invalid nodes. Expecting an array.");for(r=0,i=n.length;r<i;r++){s=n[r],Jr(s);const{key:d,attributes:a}=s;t?this.mergeNode(d,a):this.addNode(d,a)}}if(e.edges){let d=!1;if(this.type==="undirected"&&(d=!0),n=e.edges,!Array.isArray(n))throw new _("Graph.import: invalid edges. Expecting an array.");for(r=0,i=n.length;r<i;r++){u=n[r],Qr(u);const{source:a,target:h,attributes:l,undirected:y=d}=u;let v;"key"in u?(v=t?y?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:y?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,v.call(this,u.key,a,h,l)):(v=t?y?this.mergeUndirectedEdge:this.mergeDirectedEdge:y?this.addUndirectedEdge:this.addDirectedEdge,v.call(this,a,h,l))}}return this}nullCopy(e){const t=new T(B({},this._options,e));return t.replaceAttributes(B({},this.getAttributes())),t}emptyCopy(e){const t=this.nullCopy(e);return this._nodes.forEach((r,i)=>{const n=B({},r.attributes);r=new t.NodeDataClass(i,n),t._nodes.set(i,r)}),t}copy(e){if(e=e||{},typeof e.type=="string"&&e.type!==this.type&&e.type!=="mixed")throw new G(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if(typeof e.multi=="boolean"&&e.multi!==this.multi&&e.multi!==!0)throw new G("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof e.allowSelfLoops=="boolean"&&e.allowSelfLoops!==this.allowSelfLoops&&e.allowSelfLoops!==!0)throw new G("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const t=this.emptyCopy(e),r=this._edges.values();let i,n;for(;i=r.next(),i.done!==!0;)n=i.value,$t(t,"copy",!1,n.undirected,n.key,n.source.key,n.target.key,B({},n.attributes));return t}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const e={};this._nodes.forEach((n,s)=>{e[s]=n.attributes});const t={},r={};this._edges.forEach((n,s)=>{const u=n.undirected?"--":"->";let d="",a=n.source.key,h=n.target.key,l;n.undirected&&a>h&&(l=a,a=h,h=l);const y=`(${a})${u}(${h})`;s.startsWith("geid_")?this.multi&&(typeof r[y]>"u"?r[y]=0:r[y]++,d+=`${r[y]}. `):d+=`[${s}]: `,d+=y,t[d]=n.attributes});const i={};for(const n in this)this.hasOwnProperty(n)&&!At.has(n)&&typeof this[n]!="function"&&typeof n!="symbol"&&(i[n]=this[n]);return i.attributes=this._attributes,i.nodes=e,i.edges=t,Z(i,"constructor",this.constructor),i}}typeof Symbol<"u"&&(T.prototype[Symbol.for("nodejs.util.inspect.custom")]=T.prototype.inspect),ei.forEach(o=>{["add","merge","update"].forEach(e=>{const t=o.name(e),r=e==="add"?$t:ii;o.generateKey?T.prototype[t]=function(i,n,s){return r(this,t,!0,(o.type||this.type)==="undirected",null,i,n,s,e==="update")}:T.prototype[t]=function(i,n,s,u){return r(this,t,!1,(o.type||this.type)==="undirected",i,n,s,u,e==="update")}})}),fr(T),Ar(T),Tr(T),Yr(T);let Dt=class extends T{constructor(e){const t=B({type:"directed"},e);if("multi"in t&&t.multi!==!1)throw new _("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="directed")throw new _('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}},St=class extends T{constructor(e){const t=B({type:"undirected"},e);if("multi"in t&&t.multi!==!1)throw new _("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="undirected")throw new _('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}};class kt extends T{constructor(e){const t=B({multi:!0},e);if("multi"in t&&t.multi!==!0)throw new _("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class Lt extends T{constructor(e){const t=B({type:"directed",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new _("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="directed")throw new _('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class Ut extends T{constructor(e){const t=B({type:"undirected",multi:!0},e);if("multi"in t&&t.multi!==!0)throw new _("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(t.type!=="undirected")throw new _('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function he(o){o.from=function(e,t){const r=B({},e.options,t),i=new o(r);return i.import(e),i}}he(T),he(Dt),he(St),he(kt),he(Lt),he(Ut),T.Graph=T,T.DirectedGraph=Dt,T.UndirectedGraph=St,T.MultiGraph=kt,T.MultiDirectedGraph=Lt,T.MultiUndirectedGraph=Ut,T.InvalidArgumentsGraphError=_,T.NotFoundGraphError=b,T.UsageGraphError=G;function ni(o){o.prototype.updateSelectedNodesName=function(e){this.updateSelectedNodesAttributes({label:e})},o.prototype.updateSelectedNodesInfo=function(e){this.updateSelectedNodesAttributes({desc:e})},o.prototype.setDefaultNodeWeight=function(e=1){this.updateEachNodeAttributes((t,r)=>({...r,weight:e}))},o.prototype.getNodesForD3=function(){return this.nodes().map(e=>({...this.getNodeAttributes(e),id:Number(e)}))},o.prototype.selectNode=function(e){this.setNodeAttribute(e,"selected",!0)},o.prototype.deselectNode=function(e){this.setNodeAttribute(e,"selected",!1)},o.prototype.toggleNodeSelection=function(e){if((this.getNodeAttribute(e,"selected")||0)>0)this.setNodeAttribute(e,"selected",0);else{let r=0;this.forEachNode((i,n)=>{n.selected>r&&(r=n.selected)}),this.setNodeAttribute(e,"selected",r+1)}},o.prototype.getSelectedNodes=function(){return this.filterNodes((e,t)=>t.selected>0).sort((e,t)=>this.getNodeAttribute(e,"selected")-this.getNodeAttribute(t,"selected"))},o.prototype.updateSelectedNodesColor=function(e,t,r){!e||!t||!r?e?this.updateSelectedNodesAttributes({color:e}):t?this.updateSelectedNodesAttributes({stroke:t}):r&&this.updateSelectedNodesAttributes({labelColor:r}):this.updateSelectedNodesAttributes({color:e,stroke:t,labelColor:r})},o.prototype.updateSelectedNodesAttributes=function(e){this.getSelectedNodes().forEach(t=>{this.mergeNodeAttributes(t,e)})},o.prototype.connectSelectedNodes=function(e,t="directed"){const r=this.getSelectedNodes();if(!(r.length<1)){if(r.length>1)for(let i=0;i<r.length;i++)for(let n=i+1;n<r.length;n++){const s=r[i],u=r[n],d={color:e,selected:!1};this.type==="mixed"?t==="undirected"?this.mergeUndirectedEdge(s,u,d):this.mergeDirectedEdge(s,u,d):this.mergeEdge(s,u,d)}else if(this.allowSelfLoops){const i=r[0],n={color:e,selected:!1};t==="undirected"?this.mergeUndirectedEdge(i,i,n):this.mergeDirectedEdge(i,i,n)}}},o.prototype.connectSelectedNodesInOrder=function(e,t="directed"){const r=this.getSelectedNodes();for(let i=0;i<r.length-1;i++){const n=r[i],s=r[i+1],u={color:e,selected:!1};t==="undirected"?this.mergeUndirectedEdge(n,s,u):this.mergeDirectedEdge(n,s,u)}}}function oi(o){o.prototype.setDefaultEdgeWeight=function(e=1){this.updateEachEdgeAttributes((t,r)=>({...r,weight:e}))},o.prototype.getEdgeSourceTarget=function(e){return[this.source(e),this.target(e)]},o.prototype.updateSelectedEdgesName=function(e){this.updateSelectedEdgesAttributes({label:e})},o.prototype.updateSelectedEdgesInfo=function(e){this.updateSelectedEdgesAttributes({desc:e})},o.prototype.getEdgesForD3=function(){return this.edges().map(e=>{const{source:t,target:r}=this.getEdgeAttributes(e);return{source:t,target:r}})},o.prototype.selectEdge=function(e){this.setEdgeAttribute(e,"selected",!0)},o.prototype.deselectEdge=function(e){this.setEdgeAttribute(e,"selected",!1)},o.prototype.toggleEdgeSelection=function(e){if((this.getEdgeAttribute(e,"selected")||0)>0)this.setEdgeAttribute(e,"selected",0);else{let r=0;this.forEachEdge((i,n)=>{n.selected>r&&(r=n.selected)}),this.setEdgeAttribute(e,"selected",r+1)}},o.prototype.getSelectedEdges=function(){return this.filterEdges((e,t)=>t.selected>0).sort((e,t)=>this.getEdgeAttribute(e,"selected")-this.getEdgeAttribute(t,"selected"))},o.prototype.updateSelectedEdgesAttributes=function(e){this.getSelectedEdges().forEach(t=>{this.mergeEdgeAttributes(t,e)})},o.prototype.updateSelectedEdgesColor=function(e,t){const r={...e&&{color:e},...t&&{labelColor:t}};this.updateSelectedEdgesAttributes(r)},o.prototype.updateSelectedEdgesName=function(e){this.updateSelectedEdgesAttributes({label:e})},o.prototype.updateSelectedEdgesInfo=function(e){this.updateSelectedEdgesAttributes({desc:e})}}function si(o){o.prototype.addFace=function(e,t){const r=e.join("_");t={...t,key:r,id:this._faces.size,nodes:e,color:this.colors.face_color,labelColor:this.colors.label_color};var i=new ui(r,e,t);this._faces.set(r,i)},o.prototype.faces=function(){return Array.from(this._faces.keys())},o.prototype.findFace=function(e){return e.sort(),e.join("_")},o.prototype.dropFace=function(e){this._faces.has(e)&&this._faces.delete(e)},o.prototype.hasFace=function(e){return this._faces.has(e)},o.prototype.faceNodeNeighbors=function(e){const t=[];return this.forEachFace((r,i)=>{i.nodes.includes(e)&&t.push(r)}),t},o.prototype.faceEdgeNeighbors=function(e){const{source:t,target:r}=this.getEdgeAttributes(e),i=[];return this.forEachFace((n,s)=>{s.nodes.includes(""+t)&&s.nodes.includes(""+r)&&i.push(n)}),i},o.prototype.forEachFace=function(e){for(const t of this._faces.values())e(t.key,t.attributes)},o.prototype.setFaceAttribute=function(e,t,r){this._faces.get(e).attributes[t]=r},o.prototype.getFaceAttribute=function(e,t){return this._faces.get(e).attributes[t]},o.prototype.getFaceAttributes=function(e){return this._faces.get(e).attributes},o.prototype.selectFace=function(e){this.setFaceAttribute(e,"selected",!0)},o.prototype.deselectFace=function(e){this.setFaceAttribute(e,"selected",!1)},o.prototype.toggleFaceSelection=function(e){if((this.getFaceAttribute(e,"selected")||0)>0)this.setFaceAttribute(e,"selected",0);else{let r=0;this.forEachFace((i,n)=>{n.selected>r&&(r=n.selected)}),this.setFaceAttribute(e,"selected",r+1)}},o.prototype.getSelectedFaces=function(){return this.faces().filter(e=>this.getFaceAttributes(e).selected>0).sort((e,t)=>this.getFaceAttribute(e,"selected")-this.getFaceAttribute(t,"selected"))},o.prototype.updateSelectedFacesAttributes=function(e){this.getSelectedFaces().forEach(t=>{const r=this.getFaceAttributes(t);this._faces.get(t).attributes={...r,...e}})},o.prototype.updateSelectedFacesColor=function(e,t){const r={...e&&{color:e},...t&&{labelColor:t}};this.updateSelectedFacesAttributes(r)},o.prototype.updateSelectedFacesName=function(e){this.updateSelectedFacesAttributes({label:e})},o.prototype.updateSelectedFacesInfo=function(e){this.updateSelectedFacesAttributes({desc:e})},o.prototype.updateSelectedFacesWeight=function(e){this.updateSelectedFacesAttributes({weight:e})},o.prototype.deleteSelectedFaces=function(){this.getSelectedFaces().forEach(e=>this.dropFace(e))}}class ui{constructor(e,t,r){this.key=e,this.attributes=r,this.nodes=t}}function Ot(o,e=3){const t="abcdefghijklmnopqrstuvwxyz",r=[];function i(s,u,d){if(d===0){r.push(s);return}for(let a=u;a<t.length;a++)if(i(s+t[a],a+1,d-1),r.length>o)return}let n=1;for(;r.length<=o&&n<=e;)i("",0,n),n++;return r[o]||null}class ne extends T{constructor(e){super(e),this.isCustom=!0,this.defaultColors={edge_color:"#4682b4",label_color:"#000000",node_color:"#ffffff",face_color:"#4682b455",stroke_color:"#4682b4"},this.colors=this.defaultColors,this._faces=new Map,this.events()}events(){this.on("nodeAdded",({key:e})=>{const t=this.getNodeAttributes(e);t.id||this.setNodeAttribute(e,"id",+e),t.label===void 0&&this.setNodeAttribute(e,"label",Ot(t.id)),t.weight===void 0&&this.setNodeAttribute(e,"weight",void 0),t.color===void 0&&this.setNodeAttribute(e,"color",this.colors.node_color),t.stroke===void 0&&this.setNodeAttribute(e,"stroke",this.colors.stroke_color),t.labelColor===void 0&&this.setNodeAttribute(e,"labelColor",this.colors.label_color),t.selected===void 0&&this.setNodeAttribute(e,"selected",!1),t.size===void 0&&this.setNodeAttribute(e,"size",.25),t.magnitude===void 0&&this.setNodeAttribute(e,"magnitude",1),t.desc===void 0&&this.setNodeAttribute(e,"desc",{})}),this.on("edgeAdded",({key:e,source:t,target:r})=>{const i=this.getEdgeAttributes(e);i.id||this.setEdgeAttribute(e,"id",this.size-1),i.label===void 0&&this.setEdgeAttribute(e,"label",Ot(i.id)),i.weight===void 0&&this.setEdgeAttribute(e,"weight",void 0),i.color===void 0&&this.setEdgeAttribute(e,"color",this.colors.edge_color),i.labelColor===void 0&&this.setEdgeAttribute(e,"labelColor",this.colors.label_color),i.source||this.setEdgeAttribute(e,"source",Number(t)),i.target||this.setEdgeAttribute(e,"target",Number(r)),i.selected===void 0&&this.setEdgeAttribute(e,"selected",!1),i.desc===void 0&&this.setEdgeAttribute(e,"desc",{})})}validateSettings(e={}){return Object.fromEntries(Object.keys(this.defaultColors).map(t=>[t,t in e?e[t]:this.defaultColors[t]]))}_nullCopy(e){const t=new this.constructor(fe({},this._options,e));return t.replaceAttributes(fe({},this.getAttributes())),t}nullCopy(e){const t=new ne(fe({},this._options,e));return t.replaceAttributes(fe({},this.getAttributes())),t}deselectAll(){this.updateEachNodeAttributes((e,t)=>({...t,selected:0})),this.updateEachEdgeAttributes((e,t)=>({...t,selected:!1}))}deleteSelected(){this.getSelectedEdges().forEach(e=>this.dropEdge(e)),this.getSelectedNodes().forEach(e=>this.dropNode(e))}updateSelectedName(e){this.updateSelectedNodesAttributes({label:e}),this.updateSelectedEdgesAttributes({label:e}),this.updateSelectedFacesAttributes({label:e})}updateSelectedInfo(e){this.updateSelectedNodesAttributes({desc:e}),this.updateSelectedEdgesAttributes({desc:e}),this.updateSelectedFacesAttributes({desc:e})}updateSelectedWeight(e){this.updateSelectedNodesAttributes({weight:e}),this.updateSelectedEdgesAttributes({weight:e}),this.updateSelectedFacesAttributes({weight:e})}selectPath(e){this.deselectAll(),e.forEach(t=>{this.hasNode(t)&&this.selectNode(t)});for(let t=0;t<e.length-1;t++){const r=e[t],i=e[t+1];if(this.hasEdge(r,i)){const n=this.edge(r,i);this.selectEdge(n)}}}replace(e){this.clear(),this.import(e.export())}dropNode(e){const t=this.faceNodeNeighbors(e);t.length&&t.map(r=>{this.dropFace(r)}),super.dropNode(e)}dropEdge(e){var t;if(arguments.length>1){var r=""+arguments[0],i=""+arguments[1];this.findEdge(r,i,s=>{t=s})}else t=e;const n=this.faceEdgeNeighbors(t);n.length&&n.map(s=>{this.dropFace(s)}),super.dropEdge(t)}export(){const e=super.export();e.attributes.selected=!1;var t=new Array(this._faces.size),r=0;return this._faces.forEach(function(i,n){t[r++]=di(n,i)}),e.faces=t,e}import(e){const t=super.import(e);if(typeof e.faces=="function")e.forEachFace((r,i)=>{t.addFace(i.nodes,i)});else for(const r of e.faces)t.addFace(r.nodes,r.attributes);return t}subgraph(e){const t=this._nullCopy();if(!e||Array.isArray(e)&&e.length===0||e instanceof Set&&e.size===0)return t;const r=new Set(e);for(const i of r)t.addNode(i,this.getNodeAttributes(i));return this.forEachEdge((i,n,s,u,d,a,h)=>{r.has(s)&&r.has(u)&&(h?t.addUndirectedEdgeWithKey(i,s,u,n):t.addDirectedEdgeWithKey(i,s,u,n))}),this.forEachFace((i,n)=>{const s=n.nodes||[];console.log(s),s.every(u=>r.has(u)||r.has(""+u))&&t.addFace(n.nodes,n)}),t}mergeWith(e){if(this.multi!==e.multi)throw new Error("graphology-operators/disjoint-union: both graph should be simple or multi.");this.mergeAttributes(this.getAttributes());var t={},r=Math.max(...this.nodes())+1;e.forEachNode((i,n)=>{t[i]=r,this.addNode(r,{...n,id:r}),r++}),r=Math.max(...this.edges())+1,e.forEachEdge((i,n,s,u,d,a,h)=>{h?this.addUndirectedEdge(t[s],t[u],{...n,id:r++,source:t[s],target:t[u]}):this.addDirectedEdge(t[s],t[u],{...n,id:r++})}),r=Math.max(...this.faces())+1,e.forEachFace((i,n)=>{const s=n.nodes.map(u=>t[u]);this.addFace(s,{...n,id:r++,nodes:s})})}clear(){this._faces.clear(),this._edges.clear(),this._nodes.clear()}}function ai(){for(var o=arguments[0],e=1,t=arguments.length;e<t;e++)if(arguments[e])for(var r in arguments[e])o[r]=arguments[e][r];return o}var fe=ai;typeof Object.assign=="function"&&(fe=Object.assign);function di(o,e){var t={key:o,nodes:e.nodes};return Object.keys(e.attributes).length&&(t.attributes=fe({},e.attributes)),t}ni(ne),oi(ne),si(ne);class ci extends ne{constructor(e={}){const t=Object.assign({type:"directed"},e);if("multi"in t&&t.multi!==!1)throw new InvalidArgumentsGraphError("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="directed")throw new InvalidArgumentsGraphError(`DirectedGraph.from: inconsistent "${t.type}" type in given options!`);super(t)}}class hi extends ne{constructor(e={}){const t=Object.assign({type:"undirected"},e);if("multi"in t&&t.multi!==!1)throw new InvalidArgumentsGraphError("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(t.type!=="undirected")throw new InvalidArgumentsGraphError(`UndirectedGraph.from: inconsistent "${t.type}" type in given options!`);super(t)}}var le={},Ve,It;function Le(){return It||(It=1,Ve=function(e){return e!==null&&typeof e=="function"&&typeof e.prototype=="object"&&typeof e.prototype.addUndirectedEdgeWithKey=="function"&&typeof e.prototype.dropNode=="function"}),Ve}var Ze,Rt;function fi(){if(Rt)return Ze;Rt=1;var o=Le();return Ze=function(t,r){if(!o(t))throw new Error("graphology-generators/classic/complete: invalid Graph constructor.");var i=new t,n,s;for(n=0;n<r;n++)i.addNode(n);for(n=0;n<r;n++)for(s=n+1;s<r;s++)i.type!=="directed"&&i.addUndirectedEdge(n,s),i.type!=="undirected"&&(i.addDirectedEdge(n,s),i.addDirectedEdge(s,n));return i},Ze}var Je,Ct;function li(){if(Ct)return Je;Ct=1;var o=Le();return Je=function(t,r){if(!o(t))throw new Error("graphology-generators/classic/empty: invalid Graph constructor.");var i=new t,n;for(n=0;n<r;n++)i.addNode(n);return i},Je}var Qe,Nt;function pi(){if(Nt)return Qe;Nt=1;var o=Le();return Qe=function(t,r){if(!o(t))throw new Error("graphology-generators/classic/ladder: invalid Graph constructor.");var i=new t,n;for(n=0;n<r-1;n++)i.mergeEdge(n,n+1);for(n=r;n<r*2-1;n++)i.mergeEdge(n,n+1);for(n=0;n<r;n++)i.addEdge(n,n+r);return i},Qe}var Xe,Ft;function gi(){if(Ft)return Xe;Ft=1;var o=Le();return Xe=function(t,r){if(!o(t))throw new Error("graphology-generators/classic/path: invalid Graph constructor.");for(var i=new t,n=0;n<r-1;n++)i.mergeEdge(n,n+1);return i},Xe}var jt;function yi(){return jt||(jt=1,le.complete=fi(),le.empty=li(),le.ladder=pi(),le.path=gi()),le}var wi=yi(),Me,zt;function bi(){return zt||(zt=1,Me=function(e){return e!==null&&typeof e=="object"&&typeof e.addUndirectedEdgeWithKey=="function"&&typeof e.dropNode=="function"&&typeof e.multi=="boolean"}),Me}var Ee={},Tt;function mi(){if(Tt)return Ee;Tt=1;function o(r){return typeof r!="number"||isNaN(r)?1:r}function e(r,i){var n={},s=function(a){return typeof a>"u"?i:a};typeof i=="function"&&(s=i);var u=function(a){return s(a[r])},d=function(){return s(void 0)};return typeof r=="string"?(n.fromAttributes=u,n.fromGraph=function(a,h){return u(a.getNodeAttributes(h))},n.fromEntry=function(a,h){return u(h)}):typeof r=="function"?(n.fromAttributes=function(){throw new Error("graphology-utils/getters/createNodeValueGetter: irrelevant usage.")},n.fromGraph=function(a,h){return s(r(h,a.getNodeAttributes(h)))},n.fromEntry=function(a,h){return s(r(a,h))}):(n.fromAttributes=d,n.fromGraph=d,n.fromEntry=d),n}function t(r,i){var n={},s=function(a){return typeof a>"u"?i:a};typeof i=="function"&&(s=i);var u=function(a){return s(a[r])},d=function(){return s(void 0)};return typeof r=="string"?(n.fromAttributes=u,n.fromGraph=function(a,h){return u(a.getEdgeAttributes(h))},n.fromEntry=function(a,h){return u(h)},n.fromPartialEntry=n.fromEntry,n.fromMinimalEntry=n.fromEntry):typeof r=="function"?(n.fromAttributes=function(){throw new Error("graphology-utils/getters/createEdgeValueGetter: irrelevant usage.")},n.fromGraph=function(a,h){var l=a.extremities(h);return s(r(h,a.getEdgeAttributes(h),l[0],l[1],a.getNodeAttributes(l[0]),a.getNodeAttributes(l[1]),a.isUndirected(h)))},n.fromEntry=function(a,h,l,y,v,U,O){return s(r(a,h,l,y,v,U,O))},n.fromPartialEntry=function(a,h,l,y){return s(r(a,h,l,y))},n.fromMinimalEntry=function(a,h){return s(r(a,h))}):(n.fromAttributes=d,n.fromGraph=d,n.fromEntry=d,n.fromMinimalEntry=d),n}return Ee.createNodeValueGetter=e,Ee.createEdgeValueGetter=t,Ee.createEdgeWeightGetter=function(r){return t(r,o)},Ee}var et,Wt;function vi(){if(Wt)return et;Wt=1;var o=0,e=1,t=2,r=3,i=4,n=5,s=6,u=7,d=8,a=9,h=0,l=1,y=2,v=0,U=1,O=2,C=3,N=4,R=5,W=6,w=7,g=8,E=3,A=10,k=3,L=9,I=10;return et=function(F,c,pe){var it,m,f,P,q,oe,ge,x,S,nt,M=c.length,Si=pe.length,_e=F.adjustSizes,ki=F.barnesHutTheta*F.barnesHutTheta,Ue,K,j,z,ie,D,$,p=[];for(f=0;f<M;f+=A)c[f+i]=c[f+t],c[f+n]=c[f+r],c[f+t]=0,c[f+r]=0;if(F.outboundAttractionDistribution){for(Ue=0,f=0;f<M;f+=A)Ue+=c[f+s];Ue/=M/A}if(F.barnesHutOptimize){var se=1/0,ye=-1/0,ue=1/0,we=-1/0,Q,be,ot;for(f=0;f<M;f+=A)se=Math.min(se,c[f+o]),ye=Math.max(ye,c[f+o]),ue=Math.min(ue,c[f+e]),we=Math.max(we,c[f+e]);var Oe=ye-se,Ie=we-ue;for(Oe>Ie?(ue-=(Oe-Ie)/2,we=ue+Oe):(se-=(Ie-Oe)/2,ye=se+Ie),p[0+v]=-1,p[0+U]=(se+ye)/2,p[0+O]=(ue+we)/2,p[0+C]=Math.max(ye-se,we-ue),p[0+N]=-1,p[0+R]=-1,p[0+W]=0,p[0+w]=0,p[0+g]=0,it=1,f=0;f<M;f+=A)for(m=0,ot=E;;)if(p[m+R]>=0){c[f+o]<p[m+U]?c[f+e]<p[m+O]?Q=p[m+R]:Q=p[m+R]+L:c[f+e]<p[m+O]?Q=p[m+R]+L*2:Q=p[m+R]+L*3,p[m+w]=(p[m+w]*p[m+W]+c[f+o]*c[f+s])/(p[m+W]+c[f+s]),p[m+g]=(p[m+g]*p[m+W]+c[f+e]*c[f+s])/(p[m+W]+c[f+s]),p[m+W]+=c[f+s],m=Q;continue}else if(p[m+v]<0){p[m+v]=f;break}else{if(p[m+R]=it*L,x=p[m+C]/2,S=p[m+R],p[S+v]=-1,p[S+U]=p[m+U]-x,p[S+O]=p[m+O]-x,p[S+C]=x,p[S+N]=S+L,p[S+R]=-1,p[S+W]=0,p[S+w]=0,p[S+g]=0,S+=L,p[S+v]=-1,p[S+U]=p[m+U]-x,p[S+O]=p[m+O]+x,p[S+C]=x,p[S+N]=S+L,p[S+R]=-1,p[S+W]=0,p[S+w]=0,p[S+g]=0,S+=L,p[S+v]=-1,p[S+U]=p[m+U]+x,p[S+O]=p[m+O]-x,p[S+C]=x,p[S+N]=S+L,p[S+R]=-1,p[S+W]=0,p[S+w]=0,p[S+g]=0,S+=L,p[S+v]=-1,p[S+U]=p[m+U]+x,p[S+O]=p[m+O]+x,p[S+C]=x,p[S+N]=p[m+N],p[S+R]=-1,p[S+W]=0,p[S+w]=0,p[S+g]=0,it+=4,c[p[m+v]+o]<p[m+U]?c[p[m+v]+e]<p[m+O]?Q=p[m+R]:Q=p[m+R]+L:c[p[m+v]+e]<p[m+O]?Q=p[m+R]+L*2:Q=p[m+R]+L*3,p[m+W]=c[p[m+v]+s],p[m+w]=c[p[m+v]+o],p[m+g]=c[p[m+v]+e],p[Q+v]=p[m+v],p[m+v]=-1,c[f+o]<p[m+U]?c[f+e]<p[m+O]?be=p[m+R]:be=p[m+R]+L:c[f+e]<p[m+O]?be=p[m+R]+L*2:be=p[m+R]+L*3,Q===be)if(ot--){m=Q;continue}else{ot=E;break}p[be+v]=f;break}}if(F.barnesHutOptimize)for(K=F.scalingRatio,f=0;f<M;f+=A)for(m=0;;)if(p[m+R]>=0)if(D=Math.pow(c[f+o]-p[m+w],2)+Math.pow(c[f+e]-p[m+g],2),nt=p[m+C],4*nt*nt/D<ki){if(j=c[f+o]-p[m+w],z=c[f+e]-p[m+g],_e===!0?D>0?($=K*c[f+s]*p[m+W]/D,c[f+t]+=j*$,c[f+r]+=z*$):D<0&&($=-K*c[f+s]*p[m+W]/Math.sqrt(D),c[f+t]+=j*$,c[f+r]+=z*$):D>0&&($=K*c[f+s]*p[m+W]/D,c[f+t]+=j*$,c[f+r]+=z*$),m=p[m+N],m<0)break;continue}else{m=p[m+R];continue}else{if(oe=p[m+v],oe>=0&&oe!==f&&(j=c[f+o]-c[oe+o],z=c[f+e]-c[oe+e],D=j*j+z*z,_e===!0?D>0?($=K*c[f+s]*c[oe+s]/D,c[f+t]+=j*$,c[f+r]+=z*$):D<0&&($=-K*c[f+s]*c[oe+s]/Math.sqrt(D),c[f+t]+=j*$,c[f+r]+=z*$):D>0&&($=K*c[f+s]*c[oe+s]/D,c[f+t]+=j*$,c[f+r]+=z*$)),m=p[m+N],m<0)break;continue}else for(K=F.scalingRatio,P=0;P<M;P+=A)for(q=0;q<P;q+=A)j=c[P+o]-c[q+o],z=c[P+e]-c[q+e],_e===!0?(D=Math.sqrt(j*j+z*z)-c[P+d]-c[q+d],D>0?($=K*c[P+s]*c[q+s]/D/D,c[P+t]+=j*$,c[P+r]+=z*$,c[q+t]-=j*$,c[q+r]-=z*$):D<0&&($=100*K*c[P+s]*c[q+s],c[P+t]+=j*$,c[P+r]+=z*$,c[q+t]-=j*$,c[q+r]-=z*$)):(D=Math.sqrt(j*j+z*z),D>0&&($=K*c[P+s]*c[q+s]/D/D,c[P+t]+=j*$,c[P+r]+=z*$,c[q+t]-=j*$,c[q+r]-=z*$));for(S=F.gravity/F.scalingRatio,K=F.scalingRatio,f=0;f<M;f+=A)$=0,j=c[f+o],z=c[f+e],D=Math.sqrt(Math.pow(j,2)+Math.pow(z,2)),F.strongGravityMode?D>0&&($=K*c[f+s]*S):D>0&&($=K*c[f+s]*S/D),c[f+t]-=j*$,c[f+r]-=z*$;for(K=1*(F.outboundAttractionDistribution?Ue:1),ge=0;ge<Si;ge+=k)P=pe[ge+h],q=pe[ge+l],x=pe[ge+y],ie=Math.pow(x,F.edgeWeightInfluence),j=c[P+o]-c[q+o],z=c[P+e]-c[q+e],_e===!0?(D=Math.sqrt(j*j+z*z)-c[P+d]-c[q+d],F.linLogMode?F.outboundAttractionDistribution?D>0&&($=-K*ie*Math.log(1+D)/D/c[P+s]):D>0&&($=-K*ie*Math.log(1+D)/D):F.outboundAttractionDistribution?D>0&&($=-K*ie/c[P+s]):D>0&&($=-K*ie)):(D=Math.sqrt(Math.pow(j,2)+Math.pow(z,2)),F.linLogMode?F.outboundAttractionDistribution?D>0&&($=-K*ie*Math.log(1+D)/D/c[P+s]):D>0&&($=-K*ie*Math.log(1+D)/D):F.outboundAttractionDistribution?(D=1,$=-K*ie/c[P+s]):(D=1,$=-K*ie)),D>0&&(c[P+t]+=j*$,c[P+r]+=z*$,c[q+t]-=j*$,c[q+r]-=z*$);var Re,Ae,Ce,ae,Ne,Fe;if(_e===!0)for(f=0;f<M;f+=A)c[f+a]!==1&&(Re=Math.sqrt(Math.pow(c[f+t],2)+Math.pow(c[f+r],2)),Re>I&&(c[f+t]=c[f+t]*I/Re,c[f+r]=c[f+r]*I/Re),Ae=c[f+s]*Math.sqrt((c[f+i]-c[f+t])*(c[f+i]-c[f+t])+(c[f+n]-c[f+r])*(c[f+n]-c[f+r])),Ce=Math.sqrt((c[f+i]+c[f+t])*(c[f+i]+c[f+t])+(c[f+n]+c[f+r])*(c[f+n]+c[f+r]))/2,ae=.1*Math.log(1+Ce)/(1+Math.sqrt(Ae)),Ne=c[f+o]+c[f+t]*(ae/F.slowDown),c[f+o]=Ne,Fe=c[f+e]+c[f+r]*(ae/F.slowDown),c[f+e]=Fe);else for(f=0;f<M;f+=A)c[f+a]!==1&&(Ae=c[f+s]*Math.sqrt((c[f+i]-c[f+t])*(c[f+i]-c[f+t])+(c[f+n]-c[f+r])*(c[f+n]-c[f+r])),Ce=Math.sqrt((c[f+i]+c[f+t])*(c[f+i]+c[f+t])+(c[f+n]+c[f+r])*(c[f+n]+c[f+r]))/2,ae=c[f+u]*Math.log(1+Ce)/(1+Math.sqrt(Ae)),c[f+u]=Math.min(1,Math.sqrt(ae*(Math.pow(c[f+t],2)+Math.pow(c[f+r],2))/(1+Math.sqrt(Ae)))),Ne=c[f+o]+c[f+t]*(ae/F.slowDown),c[f+o]=Ne,Fe=c[f+e]+c[f+r]*(ae/F.slowDown),c[f+e]=Fe);return{}},et}var re={},Pt;function Ei(){if(Pt)return re;Pt=1;var o=10,e=3;return re.assign=function(t){t=t||{};var r=Array.prototype.slice.call(arguments).slice(1),i,n,s;for(i=0,s=r.length;i<s;i++)if(r[i])for(n in r[i])t[n]=r[i][n];return t},re.validateSettings=function(t){return"linLogMode"in t&&typeof t.linLogMode!="boolean"?{message:"the `linLogMode` setting should be a boolean."}:"outboundAttractionDistribution"in t&&typeof t.outboundAttractionDistribution!="boolean"?{message:"the `outboundAttractionDistribution` setting should be a boolean."}:"adjustSizes"in t&&typeof t.adjustSizes!="boolean"?{message:"the `adjustSizes` setting should be a boolean."}:"edgeWeightInfluence"in t&&typeof t.edgeWeightInfluence!="number"?{message:"the `edgeWeightInfluence` setting should be a number."}:"scalingRatio"in t&&!(typeof t.scalingRatio=="number"&&t.scalingRatio>=0)?{message:"the `scalingRatio` setting should be a number >= 0."}:"strongGravityMode"in t&&typeof t.strongGravityMode!="boolean"?{message:"the `strongGravityMode` setting should be a boolean."}:"gravity"in t&&!(typeof t.gravity=="number"&&t.gravity>=0)?{message:"the `gravity` setting should be a number >= 0."}:"slowDown"in t&&!(typeof t.slowDown=="number"||t.slowDown>=0)?{message:"the `slowDown` setting should be a number >= 0."}:"barnesHutOptimize"in t&&typeof t.barnesHutOptimize!="boolean"?{message:"the `barnesHutOptimize` setting should be a boolean."}:"barnesHutTheta"in t&&!(typeof t.barnesHutTheta=="number"&&t.barnesHutTheta>=0)?{message:"the `barnesHutTheta` setting should be a number >= 0."}:null},re.graphToByteArrays=function(t,r){var i=t.order,n=t.size,s={},u,d=new Float32Array(i*o),a=new Float32Array(n*e);return u=0,t.forEachNode(function(h,l){s[h]=u,d[u]=l.x,d[u+1]=l.y,d[u+2]=0,d[u+3]=0,d[u+4]=0,d[u+5]=0,d[u+6]=1,d[u+7]=1,d[u+8]=l.size||1,d[u+9]=l.fixed?1:0,u+=o}),u=0,t.forEachEdge(function(h,l,y,v,U,O,C){var N=s[y],R=s[v],W=r(h,l,y,v,U,O,C);d[N+6]+=W,d[R+6]+=W,a[u]=N,a[u+1]=R,a[u+2]=W,u+=e}),{nodes:d,edges:a}},re.assignLayoutChanges=function(t,r,i){var n=0;t.updateEachNodeAttributes(function(s,u){return u.x=r[n],u.y=r[n+1],n+=o,i?i(s,u):u})},re.readGraphPositions=function(t,r){var i=0;t.forEachNode(function(n,s){r[i]=s.x,r[i+1]=s.y,i+=o})},re.collectLayoutChanges=function(t,r,i){for(var n=t.nodes(),s={},u=0,d=0,a=r.length;u<a;u+=o){if(i){var h=Object.assign({},t.getNodeAttributes(n[d]));h.x=r[u],h.y=r[u+1],h=i(n[d],h),s[n[d]]={x:h.x,y:h.y}}else s[n[d]]={x:r[u],y:r[u+1]};d++}return s},re.createWorker=function(r){var i=window.URL||window.webkitURL,n=r.toString(),s=i.createObjectURL(new Blob(["("+n+").call(this);"],{type:"text/javascript"})),u=new Worker(s);return i.revokeObjectURL(s),u},re}var tt,Kt;function _i(){return Kt||(Kt=1,tt={linLogMode:!1,outboundAttractionDistribution:!1,adjustSizes:!1,edgeWeightInfluence:1,scalingRatio:1,strongGravityMode:!1,gravity:1,slowDown:1,barnesHutOptimize:!1,barnesHutTheta:.5}),tt}var rt,qt;function Ai(){if(qt)return rt;qt=1;var o=bi(),e=mi().createEdgeWeightGetter,t=vi(),r=Ei(),i=_i();function n(d,a,h){if(!o(a))throw new Error("graphology-layout-forceatlas2: the given graph is not a valid graphology instance.");typeof h=="number"&&(h={iterations:h});var l=h.iterations;if(typeof l!="number")throw new Error("graphology-layout-forceatlas2: invalid number of iterations.");if(l<=0)throw new Error("graphology-layout-forceatlas2: you should provide a positive number of iterations.");var y=e("getEdgeWeight"in h?h.getEdgeWeight:"weight").fromEntry,v=typeof h.outputReducer=="function"?h.outputReducer:null,U=r.assign({},i,h.settings),O=r.validateSettings(U);if(O)throw new Error("graphology-layout-forceatlas2: "+O.message);var C=r.graphToByteArrays(a,y),N;for(N=0;N<l;N++)t(U,C.nodes,C.edges);if(d){r.assignLayoutChanges(a,C.nodes,v);return}return r.collectLayoutChanges(a,C.nodes)}function s(d){var a=typeof d=="number"?d:d.order;return{barnesHutOptimize:a>2e3,strongGravityMode:!0,gravity:.05,scalingRatio:10,slowDown:1+Math.log(a)}}var u=n.bind(null,!1);return u.assign=n.bind(null,!0),u.inferSettings=s,rt=u,rt}var Gi=Ai(),$i=Ge(Gi);const Di={directed:ci,undirected:hi,mixed:ne};self.onmessage=function(o){const{type:e,graph:t,payload:r}=o.data,i=wi.empty(Di[t.options.type],0);i.import(t);let n;try{switch(e){case"force":n=$i(i,r);break;default:throw new Error(`Unknown algorithm type: ${e}`)}self.postMessage({type:e,result:n})}catch(s){self.postMessage({type:e,error:s.message})}}})();
