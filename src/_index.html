<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Static Graph with Draggable Nodes and On-Demand Simulation</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        canvas {
            border: 1px solid #ccc;
        }
        #controls {
            margin: 10px;
        }
    </style>
</head>
<body>

<div id="controls">
    <button id="startSimulation">Run Simulation</button>
</div>
<canvas width="1920" height="1080"></canvas>

<script>
    const canvas = document.querySelector("canvas");
    const context = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    let simulationStarted = false; // ðŸš€ Flag to track simulation state

    // Example Data
    const nodeCount = 500;
    const nodes = d3.range(nodeCount).map((d) => ({
        id: d,
        x: Math.random() * width,
        y: Math.random() * height
    }));

    const links = d3.range(nodeCount - 1).map((d) => ({
        source: d,
        target: d + 1
    }));

    // Force simulation (initially stopped)
    const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).distance(80))
        .force("charge", d3.forceManyBody().strength(-200))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .on("tick", ticked)
        .stop(); // ðŸš« Start manually with button

    // Drag behavior - allows dragging at all times
    d3.select(canvas)
        .call(
            d3.drag()
                .container(canvas)
                .subject(dragsubject)
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
        );

    // Button to run simulation
    document.getElementById("startSimulation").addEventListener("click", function () {
        simulationStarted = true;
        simulation.alpha(1).restart(); // âœ… Start simulation on button click
    });

    // Initial static draw
    draw();

    function ticked() {
        draw();
    }

    function draw() {
        context.clearRect(0, 0, width, height);

        // Draw links
        context.beginPath();
        links.forEach((d) => {
            context.moveTo(d.source.x, d.source.y);
            context.lineTo(d.target.x, d.target.y);
        });
        context.strokeStyle = "#aaa";
        context.stroke();

        // Draw nodes
        nodes.forEach((d) => {
            context.beginPath();
            context.arc(d.x, d.y, 10, 0, 2 * Math.PI);
            context.fillStyle = "#69b3a2";
            context.fill();
            context.strokeStyle = "#333";
            context.stroke();
        });
    }

    function dragsubject(event) {
        const x = event.x;
        const y = event.y;
        let subject = null;
        let minDist = Infinity;

        nodes.forEach((node) => {
            const dx = x - node.x;
            const dy = y - node.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 12 && dist < minDist) {
                minDist = dist;
                subject = node;
            }
        });
        return subject;
    }

    function dragstarted(event) {
        // âœ… DO NOT restart simulation if it hasn't been started manually
        if (simulationStarted && !event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
    }

    function dragged(event) {
        // âœ… Update node position immediately
        console.log(event.subject)
        event.subject.fx = event.x;
        event.subject.fy = event.y;
        if (!simulationStarted) {
            // ðŸš€ If simulation not started, just redraw to reflect changes
            event.subject.x = event.x;
            event.subject.y = event.y;
            draw();
        }
    }

    function dragended(event) {
        if (simulationStarted && !event.active) simulation.alphaTarget(0);
        // âœ… Release node from fixed position after drag
        event.subject.fx = null;
        event.subject.fy = null;
    }
</script>

</body>
</html>
